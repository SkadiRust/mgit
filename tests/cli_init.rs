use assert_cmd::prelude::*;
use std::env;
use std::path::PathBuf;
use std::process::Command;

/// test for the repos tree:
///     test_repos
///     ├─imgui-rs (.git)
///     ├─indicatif (.git)
///     ├─git-workspace (.git)
///     └─git-repo-manager (.git)
#[test]
fn cli_init_with_path_only() {
    let path = env::current_dir().unwrap().join("target\\tmp\\test_repos");

    create_repos_tree1(&path);

    let input_path = path.clone().into_os_string().into_string().unwrap();
    // excute cli init function with path
    excute_cargo_cmd("mgit", &["init", &input_path]);

    // get content from .gitrepos
    let real_result = std::fs::read_to_string(input_path + "\\.gitrepos").unwrap();
    let expect_result = r#"
# This file is automatically @generated by mgit.
# Editing it as you wish.
default-branch = "develop"

[[repos]]
local = "git-repo-manager"
remote = "https://github.com/hakoerber/git-repo-manager.git"

[[repos]]
local = "git-workspace"
remote = "https://github.com/orf/git-workspace.git"

[[repos]]
local = "imgui-rs"
remote = "https://github.com/imgui-rs/imgui-rs.git"

[[repos]]
local = "indicatif"
remote = "https://github.com/console-rs/indicatif.git"
"#;

    assert_eq!(real_result.trim(), expect_result.trim());
}

/// test for the repos tree:
///     test_repos1
///     ├─imgui-rs (.git)
///     ├─indicatif (.git)
///     ├─git-workspace (.git)
///     └─git-repo-manager (.git)
#[test]
fn cli_init_with_path_force1() {
    let path = env::current_dir().unwrap().join("target\\tmp\\test_repos1");

    create_repos_tree1(&path);

    let input_path = path.clone().into_os_string().into_string().unwrap();
    // excute cli init function with path
    excute_cargo_cmd("mgit", &["init", &input_path, "--force"]);

    // get content from .gitrepos
    let real_result = std::fs::read_to_string(input_path + "\\.gitrepos").unwrap();
    let expect_result = r#"
# This file is automatically @generated by mgit.
# Editing it as you wish.
default-branch = "develop"

[[repos]]
local = "git-repo-manager"
remote = "https://github.com/hakoerber/git-repo-manager.git"

[[repos]]
local = "git-workspace"
remote = "https://github.com/orf/git-workspace.git"

[[repos]]
local = "imgui-rs"
remote = "https://github.com/imgui-rs/imgui-rs.git"

[[repos]]
local = "indicatif"
remote = "https://github.com/console-rs/indicatif.git"
"#;

    assert_eq!(real_result.trim(), expect_result.trim());
}

/// test for the repos tree:
/// repos tree: (.git)
///     test_repos2 (.git)
///     ├─imgui-rs (.git)
///     ├─indicatif (.git)
///     ├─git-workspace (.git)
///     └─git-repo-manager (.git)
#[test]
fn cli_init_with_path_force2() {
    let path = env::current_dir().unwrap().join("target\\tmp\\test_repos2");

    create_repos_tree2(&path);

    let input_path = path.clone().into_os_string().into_string().unwrap();
    // excute cli init function with path
    excute_cargo_cmd("mgit", &["init", &input_path, "--force"]);

    // get content from .gitrepos
    let real_result = std::fs::read_to_string(input_path + "\\.gitrepos").unwrap();
    let expect_result = r#"
# This file is automatically @generated by mgit.
# Editing it as you wish.
default-branch = "develop"

[[repos]]
local = "."
remote = "https://github.com/rust-lang/git2-rs.git"

[[repos]]
local = "git-repo-manager"
remote = "https://github.com/hakoerber/git-repo-manager.git"

[[repos]]
local = "git-workspace"
remote = "https://github.com/orf/git-workspace.git"

[[repos]]
local = "imgui-rs"
remote = "https://github.com/imgui-rs/imgui-rs.git"

[[repos]]
local = "indicatif"
remote = "https://github.com/console-rs/indicatif.git"
"#;

    assert_eq!(real_result.trim(), expect_result.trim());
}

/// test for the repos tree:
/// repos tree:
///     test_repos3 (.git)
///     ├─imgui-rs (.git)
///     │  ├──imgui-rs (.git)
///     │  └──indicatif (.git)
///     ├─indicatif (.git)
///     │  ├──imgui-rs (.git)
///     │  └──indicatif (.git)
///     ├─git-workspace (.git)
///     │  ├──imgui-rs (.git)
///     │  └──indicatif (.git)
///     └─git-repo-manager (.git)
///        ├──imgui-rs (.git)
///        └──indicatif (.git)
#[test]
fn cli_init_with_path_force3() {
    let path = env::current_dir().unwrap().join("target\\tmp\\test_repos3");
    std::fs::create_dir_all(path.clone()).unwrap();

    create_repos_tree3(&path);

    let input_path = path.clone().into_os_string().into_string().unwrap();
    // excute cli init function with path
    excute_cargo_cmd("mgit", &["init", &input_path, "--force"]);

    // get content from .gitrepos
    let real_result = std::fs::read_to_string(input_path + "\\.gitrepos").unwrap();
    let expect_result = r#"
# This file is automatically @generated by mgit.
# Editing it as you wish.
default-branch = "develop"

[[repos]]
local = "."
remote = "https://github.com/rust-lang/git2-rs.git"

[[repos]]
local = "git-repo-manager"
remote = "https://github.com/hakoerber/git-repo-manager.git"

[[repos]]
local = "git-repo-manager/imgui-rs"
remote = "https://github.com/imgui-rs/imgui-rs.git"

[[repos]]
local = "git-repo-manager/indicatif"
remote = "https://github.com/console-rs/indicatif.git"

[[repos]]
local = "git-workspace"
remote = "https://github.com/orf/git-workspace.git"

[[repos]]
local = "git-workspace/imgui-rs"
remote = "https://github.com/imgui-rs/imgui-rs.git"

[[repos]]
local = "git-workspace/indicatif"
remote = "https://github.com/console-rs/indicatif.git"

[[repos]]
local = "imgui-rs"
remote = "https://github.com/imgui-rs/imgui-rs.git"

[[repos]]
local = "imgui-rs/imgui-rs"
remote = "https://github.com/imgui-rs/imgui-rs.git"

[[repos]]
local = "imgui-rs/indicatif"
remote = "https://github.com/console-rs/indicatif.git"

[[repos]]
local = "indicatif"
remote = "https://github.com/console-rs/indicatif.git"

[[repos]]
local = "indicatif/imgui-rs"
remote = "https://github.com/imgui-rs/imgui-rs.git"

[[repos]]
local = "indicatif/indicatif"
remote = "https://github.com/console-rs/indicatif.git"
"#;

    assert_eq!(real_result.trim(), expect_result.trim());
}

pub fn excute_cmd(path: &PathBuf, cmd: &str, args: &[&str]) {
    std::process::Command::new(cmd)
        .current_dir(path.to_path_buf())
        .args(args)
        .stdout(std::process::Stdio::null())
        .stderr(std::process::Stdio::null())
        .spawn()
        .unwrap()
        .wait()
        .unwrap();
}

pub fn excute_cargo_cmd(cmd: &str, args: &[&str]) {
    Command::cargo_bin(cmd)
        .unwrap()
        .args(args)
        .assert()
        .success();
}

pub fn create_repos_tree1(path: &PathBuf) {
    if path.exists() {
        std::fs::remove_dir_all(path).unwrap();
    }
    std::fs::create_dir_all(path.clone()).unwrap();

    let remotes = vec![
        "https://github.com/imgui-rs/imgui-rs.git",
        "https://github.com/console-rs/indicatif.git",
        "https://github.com/orf/git-workspace.git",
        "https://github.com/hakoerber/git-repo-manager.git",
    ];

    for idx in 0..remotes.len() {
        let pos_start = remotes[idx].rfind("/").unwrap();
        let pos_end = remotes[idx].rfind(".").unwrap();
        let repo_name = &remotes[idx][pos_start + 1..pos_end];
        let dir = path.join(repo_name);
        std::fs::create_dir_all(dir.to_path_buf()).unwrap();

        // create local git repositoris
        excute_cmd(&dir, "git", &["init"]);

        // add remote
        excute_cmd(&dir, "git", &["remote", "add", "origin", remotes[idx]]);
    }
}

pub fn create_repos_tree2(path: &PathBuf) {
    create_repos_tree1(path);

    // set root git init
    excute_cmd(path, "git", &["init"]);
    let root_remote = "https://github.com/rust-lang/git2-rs.git";
    excute_cmd(path, "git", &["remote", "add", "origin", root_remote]);
}

pub fn create_repos_tree3(path: &PathBuf) {
    // set root git init
    create_repos_tree2(path);

    let remotes = vec![
        "https://github.com/imgui-rs/imgui-rs.git",
        "https://github.com/console-rs/indicatif.git",
    ];

    // get all dir
    for it in std::fs::read_dir(path).unwrap() {
        let dir_entry = match it {
            Ok(dir) => dir,
            Err(e) => {
                println!("{}", e);
                continue;
            }
        };

        let sub_path = path.join(dir_entry.path());

        // init repo randomly
        for idx in 0..remotes.len() {
            let pos_start = remotes[idx].rfind("/").unwrap();
            let pos_end = remotes[idx].rfind(".").unwrap();
            let repo_name = &remotes[idx][pos_start + 1..pos_end];
            let dir = sub_path.join(&repo_name);
            println!("{:?}", dir);
            std::fs::create_dir_all(dir.to_path_buf()).unwrap();
            // create local git repositoris
            excute_cmd(&dir, "git", &["init"]);

            // add remote
            excute_cmd(&dir, "git", &["remote", "add", "origin", remotes[idx]]);
        }
    }
}
