use assert_cmd::prelude::*;
use std::env;
use std::path::PathBuf;
use std::process::Command;
/// test for the repos tree:
/// repos tree:
///   test_clean1
///     ├─foobar-1 (.git)
///     │  ├──foobar-1-1 (.git)
///     │  │    ├──1.txt
///     │  │    ├──2.txt
///     │  │    ├──foo
///     │  │    │   ├──1.txt
///     │  │    │   └──2.txt
///     │  │    └──bar
///     │  │        ├──1.txt
///     │  │        └──2.txt
///     │  ├──foobar-1-2
///     │  │    └──foobar-1-2-1(.git)
///     │  │        ├──1.txt
///     │  │        ├──2.txt
///     │  │        ├──foo
///     │  │        │   ├──1.txt
///     │  │        │   └──2.txt
///     │  │        └──bar
///     │  │            ├──1.txt
///     │  │            └──2.txt
///     │  ├──1.txt
///     │  ├──2.txt
///     │  ├──foo
///     │  │   ├──1.txt
///     │  │   └──2.txt
///     │  └──bar
///     │       ├──1.txt
///     │       └──2.txt
///     ├─foobar-2 (.git)
///     │  ├──foobar-2-1 (.git)
///     │  │    ├──1.txt
///     │  │    ├──2.txt
///     │  │    ├──foo
///     │  │    │   ├──1.txt
///     │  │    │   └──2.txt
///     │  │    └──bar
///     │  │        ├──1.txt
///     │  │        └──2.txt
///     │  ├──1.txt
///     │  ├──2.txt
///     │  ├──foo
///     │  │   ├──1.txt
///     │  │   └──2.txt
///     │  └──bar
///     │       ├──1.txt
///     │       └──2.txt
///     └─foobar-3 (.git)
///        ├──1.txt
///        ├──2.txt
///        ├──foo
///        │   ├──1.txt
///        │   └──2.txt
///        └──bar
///             ├──1.txt
///             └──2.txt
#[test]
fn cli_clean1() {
    let path = env::current_dir().unwrap().join("target\\tmp\\test_clean1");
    let rel_paths = vec![
        "foobar-1",
        "foobar-1/foobar-1-1",
        "foobar-1/foobar-1-2/foobar-1-2-1",
        "foobar-2",
        "foobar-2/foobar-2-1",
        "foobar-3",
    ];

    create_repos_tree(&path, &rel_paths);

    let config_file = path.join(".gitrepos");
    let toml_string = r#"
# This file is automatically @generated by mgit.
# Editing it as you wish.
default-branch = "develop"

[[repos]]
local = "foobar-1/foobar-1-2/foobar-1-2-1"
remote = "https://github.com/imgui-rs/imgui-rs.git"

[[repos]]
local = "foobar-2"
remote = "https://github.com/imgui-rs/imgui-rs.git"

[[repos]]
local = "foobar-2/foobar-2-1"
remote = "https://github.com/imgui-rs/imgui-rs.git"
"#;

    std::fs::write(config_file, toml_string.trim()).expect("Failed to write file .gitrepos!");

    execute_cargo_cmd("mgit", &["clean", path.to_str().unwrap()]);

    for rel_path in rel_paths {
        let dir = path.join(&rel_path);

        if rel_path == "foobar-1/foobar-1-2/foobar-1-2-1"
            || rel_path == "foobar-2"
            || rel_path == "foobar-2/foobar-2-1"
        {
            assert!(dir.join("1.txt").is_file());
            assert!(dir.join("2.txt").is_file());

            assert!(dir.join(".git").is_dir());

            assert!(dir.join("foo").is_dir());
            assert!(dir.join("foo/1.txt").is_file());
            assert!(dir.join("foo/2.txt").is_file());

            assert!(dir.join("bar").is_dir());
            assert!(dir.join("bar/1.txt").is_file());
            assert!(dir.join("bar/2.txt").is_file());
        } else {
            assert_eq!(false, dir.join("1.txt").is_file());
            assert_eq!(false, dir.join("2.txt").is_file());

            assert_eq!(false, dir.join(".git").is_dir());

            assert_eq!(false, dir.join("foo").is_dir());
            assert_eq!(false, dir.join("foo/1.txt").is_file());
            assert_eq!(false, dir.join("foo/2.txt").is_file());

            assert_eq!(false, dir.join("bar").is_dir());
            assert_eq!(false, dir.join("bar/1.txt").is_file());
            assert_eq!(false, dir.join("bar/2.txt").is_file());
        }
    }

    // clean-up
    std::fs::remove_dir_all(&path).unwrap();
}

/// test for the repos tree:
/// repos tree:
///   test_clean2 (.git)
///     ├─... (same as cli_clean1())

#[test]
fn cli_clean2() {
    let path = env::current_dir().unwrap().join("target\\tmp\\test_clean2");
    let rel_paths = vec![
        "./",
        "foobar-1",
        "foobar-1/foobar-1-1",
        "foobar-1/foobar-1-2/foobar-1-2-1",
        "foobar-2",
        "foobar-2/foobar-2-1",
        "foobar-3",
    ];

    create_repos_tree(&path, &rel_paths);

    let config_file = path.join(".gitrepos");
    let toml_string = r#"
# This file is automatically @generated by mgit.
# Editing it as you wish.
default-branch = "develop"

[[repos]]
local = ". "
remote = "https://github.com/imgui-rs/imgui-rs.git"

[[repos]]
local = "foobar-1/foobar-1-2/foobar-1-2-1"
remote = "https://github.com/imgui-rs/imgui-rs.git"

[[repos]]
local = "foobar-2"
remote = "https://github.com/imgui-rs/imgui-rs.git"

[[repos]]
local = "foobar-2/foobar-2-1"
remote = "https://github.com/imgui-rs/imgui-rs.git"
"#;

    std::fs::write(config_file, toml_string.trim()).expect("Failed to write file .gitrepos!");

    execute_cargo_cmd("mgit", &["clean", path.to_str().unwrap()]);

    for rel_path in rel_paths {
        let dir = path.join(&rel_path);

        if rel_path == "."
            || rel_path == "foobar-1/foobar-1-2/foobar-1-2-1"
            || rel_path == "foobar-2"
            || rel_path == "foobar-2/foobar-2-1"
        {
            assert!(dir.join("1.txt").is_file());
            assert!(dir.join("2.txt").is_file());

            assert!(dir.join(".git").is_dir());

            assert!(dir.join("foo").is_dir());
            assert!(dir.join("foo/1.txt").is_file());
            assert!(dir.join("foo/2.txt").is_file());

            assert!(dir.join("bar").is_dir());
            assert!(dir.join("bar/1.txt").is_file());
            assert!(dir.join("bar/2.txt").is_file());
        } else {
            assert_eq!(false, dir.join("1.txt").is_file());
            assert_eq!(false, dir.join("2.txt").is_file());

            assert_eq!(false, dir.join(".git").is_dir());

            assert_eq!(false, dir.join("foo").is_dir());
            assert_eq!(false, dir.join("foo/1.txt").is_file());
            assert_eq!(false, dir.join("foo/2.txt").is_file());

            assert_eq!(false, dir.join("bar").is_dir());
            assert_eq!(false, dir.join("bar/1.txt").is_file());
            assert_eq!(false, dir.join("bar/2.txt").is_file());
        }
    }

    // clean-up
    std::fs::remove_dir_all(&path).unwrap();
}

/// test for the repos tree with '--config':
/// repos tree: same as cli_clean1()
#[test]
fn cli_clean3() {
    let path = env::current_dir().unwrap().join("target\\tmp\\test_clean3");
    let rel_paths = vec![
        "foobar-1",
        "foobar-1/foobar-1-1",
        "foobar-1/foobar-1-2/foobar-1-2-1",
        "foobar-2",
        "foobar-2/foobar-2-1",
        "foobar-3",
    ];

    create_repos_tree(&path, &rel_paths);

    let config_file = path.join(".gitrepos");
    let toml_string = r#"
# This file is automatically @generated by mgit.
# Editing it as you wish.
default-branch = "develop"

[[repos]]
local = "foobar-1/foobar-1-2/foobar-1-2-1"
remote = "https://github.com/imgui-rs/imgui-rs.git"

[[repos]]
local = "foobar-2"
remote = "https://github.com/imgui-rs/imgui-rs.git"

[[repos]]
local = "foobar-2/foobar-2-1"
remote = "https://github.com/imgui-rs/imgui-rs.git"
"#;

    std::fs::write(config_file, toml_string.trim()).expect("Failed to write file .gitrepos!");

    execute_cargo_cmd(
        "mgit",
        &[
            "clean",
            path.to_str().unwrap(),
            "--config",
            path.join("./.gitrepos").to_str().unwrap(),
        ],
    );

    for rel_path in rel_paths {
        let dir = path.join(&rel_path);

        if rel_path == "foobar-1/foobar-1-2/foobar-1-2-1"
            || rel_path == "foobar-2"
            || rel_path == "foobar-2/foobar-2-1"
        {
            assert!(dir.join("1.txt").is_file());
            assert!(dir.join("2.txt").is_file());

            assert!(dir.join(".git").is_dir());

            assert!(dir.join("foo").is_dir());
            assert!(dir.join("foo/1.txt").is_file());
            assert!(dir.join("foo/2.txt").is_file());

            assert!(dir.join("bar").is_dir());
            assert!(dir.join("bar/1.txt").is_file());
            assert!(dir.join("bar/2.txt").is_file());
        } else {
            assert_eq!(false, dir.join("1.txt").is_file());
            assert_eq!(false, dir.join("2.txt").is_file());

            assert_eq!(false, dir.join(".git").is_dir());

            assert_eq!(false, dir.join("foo").is_dir());
            assert_eq!(false, dir.join("foo/1.txt").is_file());
            assert_eq!(false, dir.join("foo/2.txt").is_file());

            assert_eq!(false, dir.join("bar").is_dir());
            assert_eq!(false, dir.join("bar/1.txt").is_file());
            assert_eq!(false, dir.join("bar/2.txt").is_file());
        }
    }

    // clean-up
    std::fs::remove_dir_all(&path).unwrap();
}

pub fn create_repos_tree(path: &PathBuf, rel_paths: &Vec<&str>) {
    if path.exists() {
        std::fs::remove_dir_all(&path).unwrap();
    }
    std::fs::create_dir_all(&path).unwrap();
    let remote = "https://github.com/imgui-rs/imgui-rs.git";

    // create git repos、 some files and some folders
    for rel_path in rel_paths {
        let dir = path.join(rel_path);
        std::fs::create_dir_all(dir.to_path_buf()).unwrap();

        // create local git repositoris
        execute_cmd(&dir, "git", &["init"]);

        // add remote
        execute_cmd(&dir, "git", &["remote", "add", "origin", remote]);

        // create some files
        std::fs::File::create(dir.join("1.txt")).ok();
        std::fs::File::create(dir.join("2.txt")).ok();

        // create some folders
        std::fs::create_dir_all(dir.join("foo")).ok();
        std::fs::File::create(dir.join("foo/1.txt")).ok();
        std::fs::File::create(dir.join("foo/2.txt")).ok();
        std::fs::create_dir_all(dir.join("bar")).ok();
        std::fs::File::create(dir.join("bar/1.txt")).ok();
        std::fs::File::create(dir.join("bar/2.txt")).ok();
    }
}

pub fn execute_cmd(path: &PathBuf, cmd: &str, args: &[&str]) {
    std::process::Command::new(cmd)
        .current_dir(path.to_path_buf())
        .args(args)
        .stdout(std::process::Stdio::null())
        .stderr(std::process::Stdio::null())
        .spawn()
        .unwrap()
        .wait()
        .unwrap();
}

pub fn execute_cargo_cmd(cmd: &str, args: &[&str]) {
    Command::cargo_bin(cmd)
        .unwrap()
        .args(args)
        .assert()
        .success();
}
