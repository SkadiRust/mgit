use crate::common::{execute_cargo_cmd, execute_cmd};
use std::env;

mod common;

/// 测试内容：
///     1、运行命令:
///         - mgit track <path>
///     5、根目录是仓库
///
/// 测试目录结构:
///   test_track_simple(.git)
///     ├─.gitrepos
///     ├─foobar-1 (.git)
///     └─foobar-2 (.git)
#[test]
fn cli_track_simple() {
    let path = env::current_dir()
        .unwrap()
        .join("target/tmp/test_track_simple");
    let input_path = path.to_str().unwrap();

    let _ = std::fs::remove_dir_all(&path);
    std::fs::create_dir_all(&path).unwrap();

    let toml_string = r#"
# This file is automatically @generated by mgit.
# Editing it as you wish.
default-branch = "develop"

[[repos]]
local = "."
remote = "https://gitee.com/icze1i0n/rust-sbert.git"
branch = "master"

[[repos]]
local = "foobar-1"
remote = "https://gitee.com/icze1i0n/rust-sbert.git"
branch = "attention_highlight"

[[repos]]
local = "foobar-2"
remote = "https://gitee.com/icze1i0n/rust-sbert.git"
branch= "character_bert"
"#;
    let config_file = path.join(".gitrepos");
    std::fs::write(&config_file, toml_string.trim()).expect("Failed to write file .gitrepos!");

    // initialize repositories, with no-track
    execute_cargo_cmd(
        "mgit",
        &["sync", &input_path, "--no-checkout", "--no-track"],
    );

    let cur_branch_args = ["branch", "--show-current"];
    let tracking_args = ["rev-parse", "--symbolic-full-name", "--abbrev-ref", "@{u}"];
    let root_path = &path;
    let foobar_1_path = &path.join("foobar-1");
    let foobar_2_path = &path.join("foobar-2");
    let invald_name = "invalid".to_string();

    // root: master untracked
    let branch = execute_cmd(root_path, "git", &cur_branch_args).unwrap_or(invald_name.clone());
    assert_eq!(branch.trim(), "master");
    assert!(execute_cmd(root_path, "git", &tracking_args).is_err());

    // foobar-1: master untracked
    let branch = execute_cmd(foobar_1_path, "git", &cur_branch_args).unwrap_or(invald_name.clone());
    assert_eq!(branch.trim(), "master");
    assert!(execute_cmd(foobar_1_path, "git", &tracking_args).is_err());

    // foobar-2: master untracked
    let branch = execute_cmd(foobar_2_path, "git", &cur_branch_args).unwrap_or(invald_name.clone());
    assert_eq!(branch.trim(), "master");
    assert!(execute_cmd(foobar_2_path, "git", &tracking_args).is_err());

    let toml_string = toml_string.replace(
        r#"commit = "dc1d3dbb0383f72fd4b7adcd1a4d54abf557175d""#,
        r#"branch = "master""#,
    );
    let config_file = path.join(".gitrepos");
    std::fs::write(&config_file, toml_string.trim()).expect("Failed to write file .gitrepos!");

    // track command
    execute_cargo_cmd("mgit", &["track", &input_path]);

    // root: foobar untracked,  checkout failed
    let branch = execute_cmd(root_path, "git", &cur_branch_args).unwrap_or(invald_name.clone());
    assert_eq!(branch.trim(), "master");
    let tracking_branch =
        execute_cmd(root_path, "git", &tracking_args).unwrap_or(invald_name.clone());
    assert_eq!(tracking_branch.trim(), "origin/master");

    // foobar-1: commits/90296ef untracked
    let branch = execute_cmd(foobar_1_path, "git", &cur_branch_args).unwrap_or(invald_name.clone());
    assert_eq!(branch.trim(), "master");
    let tracking_branch =
        execute_cmd(foobar_1_path, "git", &tracking_args).unwrap_or(invald_name.clone());
    assert_eq!(tracking_branch.trim(), "origin/attention_highlight");

    // foobar-2: tags/1.0.3 untracked
    let branch = execute_cmd(foobar_2_path, "git", &cur_branch_args).unwrap_or(invald_name.clone());
    assert_eq!(branch.trim(), "master");
    let tracking_branch =
        execute_cmd(foobar_2_path, "git", &tracking_args).unwrap_or(invald_name.clone());
    assert_eq!(tracking_branch.trim(), "origin/character_bert");

    // clean-up
    std::fs::remove_dir_all(&path).unwrap();
}
