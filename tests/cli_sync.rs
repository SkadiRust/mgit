use crate::common::{execute_cargo_cmd, execute_cmd};
use std::{collections::HashSet, env, path::PathBuf};

mod common;
/// 测试内容：
///     1、运行命令 mgit sync <path>
///     2、批量同步配置文件 (.gitrepos)所有仓库，模拟 git reset --soft 到远端 commit/tag/branch
///     3、local commit 会还原成 local changes
///     4、根目录是仓库
///
/// 测试目录结构:
///   test_sync_simple(.git)
///     ├─foobar (.git)
///     └─1.txt
#[test]
fn cli_sync_simple() {
    let path = env::current_dir()
        .unwrap()
        .join("target/tmp/test_sync_simple");
    let input_path = path.to_str().unwrap();

    let _ = std::fs::remove_dir_all(&path);
    std::fs::create_dir_all(&path).unwrap();

    let toml_string = r#"
# This file is automatically @generated by mgit.
# Editing it as you wish.
default-branch = "develop"

[[repos]]
local = "."
remote = "https://gitee.com/mirrors_andygrunwald/rust-hello.git"
commit = "fb3a82a783afc89a2d3f1e40ecbf74a697445e8f"

[[repos]]
local = "foobar"
remote = "https://gitee.com/mirrors_andygrunwald/rust-hello.git"
branch = "master"
"#;
    let config_file = path.join(".gitrepos");
    std::fs::write(&config_file, toml_string.trim()).expect("Failed to write file .gitrepos!");

    // initialize the repositories tree
    execute_cargo_cmd("mgit", &["sync", &input_path, "--hard"]);

    // ignore "foobar" folder
    let ignore_file = path.join(".gitignore");
    let ingore_content = "/target\n/foobar";
    std::fs::write(&ignore_file, ingore_content.trim()).expect("Failed to write file .gitignore!");

    // create new local commit
    std::fs::File::create(path.join("1.txt")).ok();
    let _ = execute_cmd(&path, "git", &["add", "."]);
    let _ = execute_cmd(&path, "git", &["commit", "-am", "foobar"]);

    // if commit succ
    assert!(execute_cmd(&path, "git", &["status"]).is_ok());

    // sync --hard will delete .gitrepos in the front
    std::fs::write(&config_file, toml_string.trim()).expect("Failed to write file .gitrepos!");
    // excute sync
    execute_cargo_cmd("mgit", &["sync", &input_path]);

    // compaire changes after sync
    if let Ok(output) = execute_cmd(&path, "git", &["status"]) {
        assert!(
            output.contains(".gitignore")
                && output.contains("1.txt")
                && output.contains(".gitrepos")
        );
    } else {
        panic!("git status error.")
    }

    // clean-up
    std::fs::remove_dir_all(&path).unwrap();
}

/// 测试内容：
///     1、运行命令 mgit sync <path>
///     2、模拟远端 commit/tag/branch 失效时的情况
///     3、commit 会还原成 local changes
///     4、根目录是仓库
///
/// 测试目录结构:
///   test_sync_tracking_invalid(.git)
///     ├─foobar (.git)
///     └─1.txt
#[test]
fn cli_sync_simple_tracking_invalid() {
    let path = env::current_dir()
        .unwrap()
        .join("target/tmp/test_sync_simple_tracking_invalid");
    let input_path = path.to_str().unwrap();

    let _ = std::fs::remove_dir_all(&path);
    std::fs::create_dir_all(&path).unwrap();

    let toml_string = r#"
# This file is automatically @generated by mgit.
# Editing it as you wish.
default-branch = "develop"

[[repos]]
local = "."
remote = "https://gitee.com/mirrors_andygrunwald/rust-hello.git"
branch = "master"

[[repos]]
local = "foobar"
remote = "https://gitee.com/mirrors_andygrunwald/rust-hello.git"
branch = "master"
"#;
    let config_file = path.join(".gitrepos");
    std::fs::write(&config_file, toml_string.trim()).expect("Failed to write file .gitrepos!");

    // initialize the repositories tree
    execute_cargo_cmd("mgit", &["sync", &input_path, "--hard"]);

    // ignore "foobar" folder
    let ignore_file = path.join(".gitignore");
    let ingore_content = "/target\n/foobar";
    std::fs::write(&ignore_file, ingore_content.trim()).expect("Failed to write file .gitignore!");

    // create new local commit
    std::fs::File::create(path.join("1.txt")).ok();

    // compaire changes now
    if let Ok(output) = execute_cmd(&path, "git", &["status"]) {
        assert!(output.contains(".gitignore") && output.contains("1.txt"));
    } else {
        panic!("status error.")
    }

    // set invalid branch
    let toml_string = toml_string.replace("master", "invalid-branch");
    // sync --hard will delete .gitrepos in the front
    std::fs::write(&config_file, toml_string.trim()).expect("Failed to write file .gitrepos!");
    // excute sync
    execute_cargo_cmd("mgit", &["sync", &input_path]);

    // compaire changes after sync
    if let Ok(output) = execute_cmd(&path, "git", &["status"]) {
        assert!(output.contains(".gitignore") && output.contains("1.txt"));
    } else {
        panic!("sync error.")
    }

    // clean-up
    std::fs::remove_dir_all(&path).unwrap();
}

/// 测试内容：
///     1、运行命令 mgit sync <path> --stash
///     2、测试 sync 时，先 stash local changes，再 reset 到远端 commit/tag/branch
///     3、根目录是仓库
///
/// 测试目录结构:
///   test_sync_stash(.git)
///     ├─foobar (.git)
///     └─1.txt
#[test]
fn cli_sync_stash() {
    let path = env::current_dir()
        .unwrap()
        .join("target/tmp/test_sync_stash");
    let input_path = path.to_str().unwrap();

    let _ = std::fs::remove_dir_all(&path);
    std::fs::create_dir_all(&path).unwrap();

    let toml_string = r#"
# This file is automatically @generated by mgit.
# Editing it as you wish.
default-branch = "develop"

[[repos]]
local = "."
remote = "https://gitee.com/mirrors_andygrunwald/rust-hello.git"
branch = "master"

[[repos]]
local = "foobar"
remote = "https://gitee.com/mirrors_andygrunwald/rust-hello.git"
branch = "master"
"#;
    let config_file = path.join(".gitrepos");
    std::fs::write(&config_file, toml_string.trim()).expect("Failed to write file .gitrepos!");

    // initialize the repositories tree
    execute_cargo_cmd("mgit", &["sync", &input_path, "--hard"]);

    // ignore "foobar" folder
    let ignore_file = path.join(".gitignore");
    let ingore_content = "/target\n/foobar";
    std::fs::write(&ignore_file, ingore_content.trim()).expect("Failed to write file .gitignore!");

    // create new local commit
    std::fs::File::create(path.join("1.txt")).ok();

    // compaire changes now
    if let Ok(output) = execute_cmd(&path, "git", &["status"]) {
        assert!(output.contains(".gitignore") && output.contains("1.txt"));
    } else {
        panic!("status error.")
    }

    // sync --hard will delete .gitrepos in the front
    std::fs::write(&config_file, toml_string.trim()).expect("Failed to write file .gitrepos!");

    // excute sync
    execute_cargo_cmd("mgit", &["sync", &input_path, "--stash"]);

    // compaire changes after sync
    if let Ok(output) = execute_cmd(&path, "git", &["status"]) {
        assert!(
            !output.contains(".gitignore")
                && !output.contains("1.txt")
                && !output.contains(".gitrepos")
        );
    } else {
        panic!("sync error.")
    }

    // check stash
    if let Ok(output) = execute_cmd(&path, "git", &["stash", "list"]) {
        assert!(output.lines().count() == 1);
    } else {
        panic!("stash error.")
    }

    // pop stash and check file
    if let Ok(output) = execute_cmd(&path, "git", &["stash", "pop"]) {
        assert!(
            output.contains(".gitignore")
                && output.contains("1.txt")
                && output.contains(".gitrepos")
        );
    } else {
        panic!("stash pop error.")
    }

    // clean-up
    std::fs::remove_dir_all(&path).unwrap();
}

/// 测试内容：
///     1、运行命令 mgit sync <path> --stash
///     2、测试远端 commit/tag/branch 失时导致 sync 失败，将 stash 的内容（若有的话）pop 出来
///     3、根目录是仓库
///
/// 测试目录结构:
///   test_sync_stash(.git)
///     ├─foobar (.git)
///     └─1.txt
#[test]
fn cli_sync_stash_tracking_invalid() {
    let path = env::current_dir()
        .unwrap()
        .join("target/tmp/test_sync_stash_tracking_invalid");
    let input_path = path.to_str().unwrap();

    let _ = std::fs::remove_dir_all(&path);
    std::fs::create_dir_all(&path).unwrap();

    let toml_string = r#"
# This file is automatically @generated by mgit.
# Editing it as you wish.
default-branch = "develop"

[[repos]]
local = "."
remote = "https://gitee.com/mirrors_andygrunwald/rust-hello.git"
branch = "master"

[[repos]]
local = "foobar"
remote = "https://gitee.com/mirrors_andygrunwald/rust-hello.git"
branch = "master"
"#;
    let config_file = path.join(".gitrepos");
    std::fs::write(&config_file, toml_string.trim()).expect("Failed to write file .gitrepos!");

    // initialize the repositories tree
    execute_cargo_cmd("mgit", &["sync", &input_path, "--hard"]);

    // ignore "foobar" folder
    let ignore_file = path.join(".gitignore");
    let ingore_content = "/target\n/foobar";
    std::fs::write(&ignore_file, ingore_content.trim()).expect("Failed to write file .gitignore!");

    // create new local commit
    std::fs::File::create(path.join("1.txt")).ok();

    // compaire changes now
    if let Ok(output) = execute_cmd(&path, "git", &["status"]) {
        assert!(output.contains(".gitignore") && output.contains("1.txt"));
    } else {
        panic!("status error.")
    }

    // set invalid branch
    let toml_string = toml_string.replace("master", "invalid-branch");
    // sync --hard will delete .gitrepos in the front
    std::fs::write(&config_file, toml_string.trim()).expect("Failed to write file .gitrepos!");
    // excute sync --stash

    execute_cargo_cmd("mgit", &["sync", &input_path, "--stash"]);

    // compaire changes after sync
    // nothing will be stash
    if let Ok(output) = execute_cmd(&path, "git", &["status"]) {
        assert!(
            output.contains(".gitignore")
                && output.contains(".gitrepos")
                && output.contains("1.txt")
        );
    } else {
        panic!("sync error.")
    }

    // clean-up
    std::fs::remove_dir_all(&path).unwrap();
}

/// cmd: 'mgit sync ./target/tmp/test_sync_hard --hard'
/// 测试内容：
///     1、运行命令 mgit sync <path> --hard
///     2、测试 sync后, 丢弃所有 changes
///     3、根目录是仓库
///
/// 测试目录结构:
///   test_sync_hard(.git)
///     ├─foobar (.git)
///     └─1.txt
#[test]
fn cli_sync_hard() {
    let path = env::current_dir()
        .unwrap()
        .join("target/tmp/test_sync_hard");
    let input_path = path.to_str().unwrap();

    let _ = std::fs::remove_dir_all(&path);
    std::fs::create_dir_all(&path).unwrap();

    let toml_string = r#"
# This file is automatically @generated by mgit.
# Editing it as you wish.
default-branch = "develop"

[[repos]]
local = "."
remote = "https://gitee.com/mirrors_andygrunwald/rust-hello.git"
commit = "fb3a82a783afc89a2d3f1e40ecbf74a697445e8f"

[[repos]]
local = "foobar"
remote = "https://gitee.com/mirrors_andygrunwald/rust-hello.git"
branch = "master"
"#;
    let config_file = path.join(".gitrepos");
    std::fs::write(&config_file, toml_string.trim()).expect("Failed to write file .gitrepos!");

    // initialize the repositories tree
    execute_cargo_cmd("mgit", &["sync", &input_path, "--hard"]);

    // ignore "foobar" folder
    let ignore_file = path.join(".gitignore");
    let ingore_content = "/target\n/foobar";
    std::fs::write(&ignore_file, ingore_content.trim()).expect("Failed to write file .gitignore!");

    // create new local commit
    std::fs::File::create(path.join("1.txt")).ok();
    let _ = execute_cmd(&path, "git", &["add", "."]);
    let _ = execute_cmd(&path, "git", &["commit", "-am", "foobar"]);

    // if commit succ
    assert!(execute_cmd(&path, "git", &["status"]).is_ok());

    // sync --hard will delete .gitrepos in the front
    std::fs::write(&config_file, toml_string.trim()).expect("Failed to write file .gitrepos!");
    // excute sync --hard
    execute_cargo_cmd("mgit", &["sync", &input_path, "--hard"]);

    // ignore "foobar" folder
    std::fs::write(&ignore_file, ingore_content.trim()).expect("Failed to write file .gitignore!");
    // compaire changes after sync
    if let Ok(output) = execute_cmd(&path, "git", &["status"]) {
        assert!(
            output.contains(".gitignore")
                && !output.contains("1.txt")
                && !output.contains(".gitrepos")
        );
    } else {
        panic!("sync error.")
    }

    // clean-up
    std::fs::remove_dir_all(&path).unwrap();
}

/// 测试内容：
///     1、运行命令 mgit sync <path> --config
///     2、path 指向的目录不存在时，自动创建目录
///     3、sync 后，changes 数量为 0
///     4、根目录是仓库
///
/// 测试目录结构:
///   test_sync_simple_invalid_path
///     ├─.gitrepos
///     └─foobar-1
///         ├─foobar (.git)
///         └─1.txt
#[test]
fn cli_sync_simple_invalid_path() {
    let path = env::current_dir()
        .unwrap()
        .join("target/tmp/test_sync_simple_invalid_path");

    let _ = std::fs::remove_dir_all(&path);
    std::fs::create_dir_all(&path).unwrap();

    let input_path = path.join("foobar-1");

    let toml_string = r#"
# This file is automatically @generated by mgit.
# Editing it as you wish.
default-branch = "develop"

[[repos]]
local = "."
remote = "https://gitee.com/mirrors_andygrunwald/rust-hello.git"
commit = "fb3a82a783afc89a2d3f1e40ecbf74a697445e8f"

[[repos]]
local = "foobar-1-1"
remote = "https://gitee.com/mirrors_andygrunwald/rust-hello.git"
branch = "master"
"#;

    let config_file = path.join(".gitrepos");
    std::fs::write(&config_file, toml_string.trim()).expect("Failed to write file .gitrepos!");
    assert!(config_file.is_file());
    assert_eq!(false, input_path.is_dir());

    // initialize the repositories tree
    common::execute_cargo_cmd(
        "mgit",
        &[
            "sync",
            input_path.to_str().unwrap(),
            "--config",
            config_file.to_str().unwrap(),
        ],
    );

    assert!(input_path.is_dir());

    let _ = execute_cmd(&path, "git", &["add", "."]);
    // ignore "foobar" folder
    let ignore_file = input_path.join(".gitignore");
    let ingore_content = "/target\n/foobar-1-1";
    std::fs::write(&ignore_file, ingore_content.trim()).expect("Failed to write file .gitignore!");

    // for foobar-1, local changes only contain ".gitignore"
    let local_changes1 = get_local_changes(&input_path);
    assert!(local_changes1.len() == 1 && local_changes1.contains(".gitignore"));

    // for foobar-1/foobar-1-1, local changes is empty
    let local_changes2 = get_local_changes(&input_path.join("foobar-1-1"));
    assert!(local_changes2.is_empty());

    // clean-up
    std::fs::remove_dir_all(&path).unwrap();
}

/// 测试内容：
///     1、运行命令 mgit sync <path> --config --stash
///     2、path 指向的目录不存在时，自动创建目录
///     3、sync 后，changes 数量为 0
///     4、根目录是仓库
///
/// 测试目录结构:
///   test_sync_stash_invalid_path
///     ├─.gitrepos
///     └─foobar-1
///         ├─foobar (.git)
///         └─1.txt
#[test]
fn cli_sync_stash_invalid_path() {
    let path = env::current_dir()
        .unwrap()
        .join("target/tmp/test_sync_stash_invalid_path");

    let _ = std::fs::remove_dir_all(&path);
    std::fs::create_dir_all(&path).unwrap();

    let input_path = path.join("foobar-1");

    let toml_string = r#"
# This file is automatically @generated by mgit.
# Editing it as you wish.
default-branch = "develop"

[[repos]]
local = "."
remote = "https://gitee.com/mirrors_andygrunwald/rust-hello.git"
commit = "fb3a82a783afc89a2d3f1e40ecbf74a697445e8f"

[[repos]]
local = "foobar-1-1"
remote = "https://gitee.com/mirrors_andygrunwald/rust-hello.git"
branch = "master"
"#;

    let config_file = path.join(".gitrepos");
    std::fs::write(&config_file, toml_string.trim()).expect("Failed to write file .gitrepos!");
    assert!(config_file.is_file());
    assert_eq!(false, input_path.is_dir());

    // initialize the repositories tree
    common::execute_cargo_cmd(
        "mgit",
        &[
            "sync",
            input_path.to_str().unwrap(),
            "--config",
            config_file.to_str().unwrap(),
            "--stash",
        ],
    );
    assert!(input_path.is_dir());

    let _ = execute_cmd(&path, "git", &["add", "."]);
    // ignore "foobar" folder
    let ignore_file = input_path.join(".gitignore");
    let ingore_content = "/target\n/foobar-1-1";
    std::fs::write(&ignore_file, ingore_content.trim()).expect("Failed to write file .gitignore!");

    // for foobar-1, local changes only contain ".gitignore"
    let local_changes1 = get_local_changes(&input_path);
    assert!(local_changes1.len() == 1 && local_changes1.contains(".gitignore"));

    // for foobar-1/foobar-1-1, local changes is empty
    let local_changes2 = get_local_changes(&input_path.join("foobar-1-1"));
    assert!(local_changes2.is_empty());

    // clean-up
    std::fs::remove_dir_all(&path).unwrap();
}

/// 测试内容：
///     1、运行命令 mgit sync <path> --config --hard
///     2、path 指向的目录不存在时，自动创建目录
///     3、sync 后，changes 数量为 0
///     4、根目录是仓库
///
/// 测试目录结构:
///   test_sync_hard_invalid_path
///     ├─.gitrepos
///     └─foobar-1
///         ├─foobar (.git)
///         └─1.txt
#[test]
fn cli_sync_hard_invalid_path() {
    let path = env::current_dir()
        .unwrap()
        .join("target/tmp/test_sync_hard_invalid_path");

    let _ = std::fs::remove_dir_all(&path);
    std::fs::create_dir_all(&path).unwrap();

    let input_path = path.join("foobar-1");

    let toml_string = r#"
# This file is automatically @generated by mgit.
# Editing it as you wish.
default-branch = "develop"

[[repos]]
local = "."
remote = "https://gitee.com/mirrors_andygrunwald/rust-hello.git"
commit = "fb3a82a783afc89a2d3f1e40ecbf74a697445e8f"

[[repos]]
local = "foobar-1-1"
remote = "https://gitee.com/mirrors_andygrunwald/rust-hello.git"
branch = "master"
"#;

    let config_file = path.join(".gitrepos");
    std::fs::write(&config_file, toml_string.trim()).expect("Failed to write file .gitrepos!");
    assert!(config_file.is_file());
    assert_eq!(false, input_path.is_dir());

    // initialize the repositories tree
    common::execute_cargo_cmd(
        "mgit",
        &[
            "sync",
            input_path.to_str().unwrap(),
            "--config",
            config_file.to_str().unwrap(),
            "--hard",
        ],
    );
    assert!(input_path.is_dir());

    let _ = execute_cmd(&path, "git", &["add", "."]);
    // ignore "foobar" folder
    let ignore_file = input_path.join(".gitignore");
    let ingore_content = "/target\n/foobar-1-1";
    std::fs::write(&ignore_file, ingore_content.trim()).expect("Failed to write file .gitignore!");

    // for foobar-1, local changes only contain ".gitignore"
    let local_changes1 = get_local_changes(&input_path);
    assert!(local_changes1.len() == 1 && local_changes1.contains(".gitignore"));

    // for foobar-1/foobar-1-1, local changes is empty
    let local_changes2 = get_local_changes(&input_path.join("foobar-1-1"));
    assert!(local_changes2.is_empty());

    // clean-up
    std::fs::remove_dir_all(&path).unwrap();
}

/// get local changes
fn get_local_changes(input_path: &PathBuf) -> HashSet<String> {
    let mut changed_files: HashSet<String> = HashSet::new();

    // get untracked files (uncommit)
    let args = ["ls-files", ".", "--exclude-standard", "--others"];
    if let Ok(output) = execute_cmd(input_path, "git", &args) {
        for file in output.trim().lines() {
            changed_files.insert(file.to_string());
        }
    }

    // get tracked and changed files (uncommit)
    let args = ["diff", "--name-only"];
    if let Ok(output) = execute_cmd(input_path, "git", &args) {
        for file in output.trim().lines() {
            changed_files.insert(file.to_string());
        }
    }

    // get cached(staged) files (uncommit)
    let args = ["diff", "--cached", "--name-only"];
    if let Ok(output) = execute_cmd(input_path, "git", &args) {
        for file in output.trim().lines() {
            changed_files.insert(file.to_string());
        }
    }

    changed_files
}
