use assert_cmd::prelude::*;
use std::env;
use std::path::PathBuf;
use std::process::Command;

/// cmd: 'mgit sync ./target/tmp/test_sync_simple'
/// repos tree:
///   test_sync_simple(.git)
///     ├─foobar (.git)
///     └─1.txt
#[test]
fn cli_sync_simple() {
    let path = env::current_dir()
        .unwrap()
        .join("target/tmp/test_sync_simple");
    let input_path = path.to_str().unwrap();

    let _ = std::fs::remove_dir_all(&path);
    std::fs::create_dir_all(&path).unwrap();

    let toml_string = r#"
# This file is automatically @generated by mgit.
# Editing it as you wish.
default-branch = "develop"

[[repos]]
local = "."
remote = "https://github.com/fly-apps/hello-rust.git"
commit = "5d1ed90a208da9f3ac6e23c4bd396933fa16f857"

[[repos]]
local = "foobar"
remote = "https://github.com/fly-apps/hello-rust.git"
branch = "main"
"#;
    let config_file = path.join(".gitrepos");
    std::fs::write(&config_file, toml_string.trim()).expect("Failed to write file .gitrepos!");

    // initialize the repositories tree
    execute_cargo_cmd("mgit", &["sync", &input_path, "--hard"]);

    // ignore "foobar" folder
    let ignore_file = path.join(".gitignore");
    let ingore_content = "/target\n/foobar";
    std::fs::write(&ignore_file, ingore_content.trim()).expect("Failed to write file .gitignore!");

    // create new local commit
    std::fs::File::create(path.join("1.txt")).ok();
    let _ = execute_cmd(&path, "git", &["add", "."]);
    let _ = execute_cmd(&path, "git", &["commit", "-am", "foobar"]);

    // compaire changes after commit
    if let Ok(output) = execute_cmd(&path, "git", &["status"]) {
        assert_eq!(
            output.trim(),
            "On branch master\nnothing to commit, working tree clean"
        );
    }

    // sync --hard will delete .gitrepos in the front
    std::fs::write(&config_file, toml_string.trim()).expect("Failed to write file .gitrepos!");
    // excute sync
    execute_cargo_cmd("mgit", &["sync", &input_path]);

    // compaire changes after sync
    if let Ok(output) = execute_cmd(&path, "git", &["status"]) {
        assert!(
            output.contains(".gitignore")
                && output.contains("1.txt")
                && output.contains(".gitrepos")
        );
    } else {
        panic!("git status error.")
    }

    // clean-up
    std::fs::remove_dir_all(&path).unwrap();
}

/// cmd: 'mgit sync ./target/tmp/test_sync_simple_tracking_invalid'
/// repos tree:
///   test_sync_tracking_invalid(.git)
///     ├─foobar (.git)
///     └─1.txt
#[test]
fn cli_sync_simple_tracking_invalid() {
    let path = env::current_dir()
        .unwrap()
        .join("target/tmp/test_sync_simple_tracking_invalid");
    let input_path = path.to_str().unwrap();

    let _ = std::fs::remove_dir_all(&path);
    std::fs::create_dir_all(&path).unwrap();

    let toml_string = r#"
# This file is automatically @generated by mgit.
# Editing it as you wish.
default-branch = "develop"

[[repos]]
local = "."
remote = "https://github.com/fly-apps/hello-rust.git"
branch = "main"

[[repos]]
local = "foobar"
remote = "https://github.com/fly-apps/hello-rust.git"
branch = "main"
"#;
    let config_file = path.join(".gitrepos");
    std::fs::write(&config_file, toml_string.trim()).expect("Failed to write file .gitrepos!");

    // initialize the repositories tree
    execute_cargo_cmd("mgit", &["sync", &input_path, "--hard"]);

    // ignore "foobar" folder
    let ignore_file = path.join(".gitignore");
    let ingore_content = "/target\n/foobar";
    std::fs::write(&ignore_file, ingore_content.trim()).expect("Failed to write file .gitignore!");

    // create new local commit
    std::fs::File::create(path.join("1.txt")).ok();

    // compaire changes now
    if let Ok(output) = execute_cmd(&path, "git", &["status"]) {
        assert!(output.contains(".gitignore") && output.contains("1.txt"));
    } else {
        panic!("status error.")
    }

    // set invalid branch
    let toml_string = toml_string.replace("main", "invalid-branch");
    // sync --hard will delete .gitrepos in the front
    std::fs::write(&config_file, toml_string.trim()).expect("Failed to write file .gitrepos!");
    // excute sync
    execute_cargo_cmd("mgit", &["sync", &input_path]);

    // compaire changes after sync
    if let Ok(output) = execute_cmd(&path, "git", &["status"]) {
        assert!(output.contains(".gitignore") && output.contains("1.txt"));
    } else {
        panic!("sync error.")
    }

    // clean-up
    std::fs::remove_dir_all(&path).unwrap();
}

/// cmd: 'mgit sync ./target/tmp/test_sync_simple --stash'
/// repos tree:
///   test_sync_stash(.git)
///     ├─foobar (.git)
///     └─1.txt
#[test]
fn cli_sync_stash() {
    let path = env::current_dir()
        .unwrap()
        .join("target/tmp/test_sync_stash");
    let input_path = path.to_str().unwrap();

    let _ = std::fs::remove_dir_all(&path);
    std::fs::create_dir_all(&path).unwrap();

    let toml_string = r#"
# This file is automatically @generated by mgit.
# Editing it as you wish.
default-branch = "develop"

[[repos]]
local = "."
remote = "https://github.com/fly-apps/hello-rust.git"
branch = "main"

[[repos]]
local = "foobar"
remote = "https://github.com/fly-apps/hello-rust.git"
branch = "main"
"#;
    let config_file = path.join(".gitrepos");
    std::fs::write(&config_file, toml_string.trim()).expect("Failed to write file .gitrepos!");

    // initialize the repositories tree
    execute_cargo_cmd("mgit", &["sync", &input_path, "--hard"]);

    // ignore "foobar" folder
    let ignore_file = path.join(".gitignore");
    let ingore_content = "/target\n/foobar";
    std::fs::write(&ignore_file, ingore_content.trim()).expect("Failed to write file .gitignore!");

    // create new local commit
    std::fs::File::create(path.join("1.txt")).ok();

    // compaire changes now
    if let Ok(output) = execute_cmd(&path, "git", &["status"]) {
        assert!(output.contains(".gitignore") && output.contains("1.txt"));
    } else {
        panic!("status error.")
    }

    // sync --hard will delete .gitrepos in the front
    std::fs::write(&config_file, toml_string.trim()).expect("Failed to write file .gitrepos!");

    // excute sync
    execute_cargo_cmd("mgit", &["sync", &input_path, "--stash"]);

    // compaire changes after sync
    if let Ok(output) = execute_cmd(&path, "git", &["status"]) {
        assert!(
            !output.contains(".gitignore")
                && !output.contains("1.txt")
                && !output.contains(".gitrepos")
        );
    } else {
        panic!("sync error.")
    }

    // check stash
    if let Ok(output) = execute_cmd(&path, "git", &["stash", "list"]) {
        assert!(output.lines().count() == 1);
    } else {
        panic!("stash error.")
    }

    // pop stash and check file
    if let Ok(output) = execute_cmd(&path, "git", &["stash", "pop"]) {
        assert!(
            output.contains(".gitignore")
                && output.contains("1.txt")
                && output.contains(".gitrepos")
        );
    } else {
        panic!("stash pop error.")
    }

    // clean-up
    std::fs::remove_dir_all(&path).unwrap();
}

// cmd: 'mgit sync ./target/tmp/test_sync_stash_tracking_invalid --stash'
/// repos tree:
///   test_sync_stash(.git)
///     ├─foobar (.git)
///     └─1.txt
#[test]
fn cli_sync_stash_tracking_invalid() {
    let path = env::current_dir()
        .unwrap()
        .join("target/tmp/test_sync_stash_tracking_invalid()");
    let input_path = path.to_str().unwrap();

    let _ = std::fs::remove_dir_all(&path);
    std::fs::create_dir_all(&path).unwrap();

    let toml_string = r#"
# This file is automatically @generated by mgit.
# Editing it as you wish.
default-branch = "develop"

[[repos]]
local = "."
remote = "https://github.com/fly-apps/hello-rust.git"
branch = "main"

[[repos]]
local = "foobar"
remote = "https://github.com/fly-apps/hello-rust.git"
branch = "main"
"#;
    let config_file = path.join(".gitrepos");
    std::fs::write(&config_file, toml_string.trim()).expect("Failed to write file .gitrepos!");

    // initialize the repositories tree
    execute_cargo_cmd("mgit", &["sync", &input_path, "--hard"]);

    // ignore "foobar" folder
    let ignore_file = path.join(".gitignore");
    let ingore_content = "/target\n/foobar";
    std::fs::write(&ignore_file, ingore_content.trim()).expect("Failed to write file .gitignore!");

    // create new local commit
    std::fs::File::create(path.join("1.txt")).ok();

    // compaire changes now
    if let Ok(output) = execute_cmd(&path, "git", &["status"]) {
        assert!(output.contains(".gitignore") && output.contains("1.txt"));
    } else {
        panic!("status error.")
    }

    // set invalid branch
    let toml_string = toml_string.replace("main", "invalid-branch");
    // sync --hard will delete .gitrepos in the front
    std::fs::write(&config_file, toml_string.trim()).expect("Failed to write file .gitrepos!");
    // excute sync --stash
    execute_cargo_cmd("mgit", &["sync", &input_path, "--stash"]);

    // compaire changes after sync
    // nothing will be stash
    if let Ok(output) = execute_cmd(&path, "git", &["status"]) {
        assert!(
            output.contains(".gitignore")
                && output.contains(".gitrepos")
                && output.contains("1.txt")
        );
    } else {
        panic!("sync error.")
    }

    // clean-up
    std::fs::remove_dir_all(&path).unwrap();
}

/// cmd: 'mgit sync ./target/tmp/test_sync_hard --hard'
/// repos tree:
///   test_sync_hard(.git)
///     ├─foobar (.git)
///     └─1.txt
#[test]
fn cli_sync_hard() {
    let path = env::current_dir()
        .unwrap()
        .join("target/tmp/test_sync_hard");
    let input_path = path.to_str().unwrap();

    let _ = std::fs::remove_dir_all(&path);
    std::fs::create_dir_all(&path).unwrap();

    let toml_string = r#"
# This file is automatically @generated by mgit.
# Editing it as you wish.
default-branch = "develop"

[[repos]]
local = "."
remote = "https://github.com/fly-apps/hello-rust.git"
commit = "5d1ed90a208da9f3ac6e23c4bd396933fa16f857"

[[repos]]
local = "foobar"
remote = "https://github.com/fly-apps/hello-rust.git"
branch = "main"
"#;
    let config_file = path.join(".gitrepos");
    std::fs::write(&config_file, toml_string.trim()).expect("Failed to write file .gitrepos!");

    // initialize the repositories tree
    execute_cargo_cmd("mgit", &["sync", &input_path, "--hard"]);

    // ignore "foobar" folder
    let ignore_file = path.join(".gitignore");
    let ingore_content = "/target\n/foobar";
    std::fs::write(&ignore_file, ingore_content.trim()).expect("Failed to write file .gitignore!");

    // create new local commit
    std::fs::File::create(path.join("1.txt")).ok();
    let _ = execute_cmd(&path, "git", &["add", "."]);
    let _ = execute_cmd(&path, "git", &["commit", "-am", "foobar"]);

    // compaire changes after commit
    if let Ok(output) = execute_cmd(&path, "git", &["status"]) {
        assert_eq!(
            output.trim(),
            "On branch master\nnothing to commit, working tree clean"
        );
    } else {
        panic!("commit error.")
    }

    // sync --hard will delete .gitrepos in the front
    std::fs::write(&config_file, toml_string.trim()).expect("Failed to write file .gitrepos!");
    // excute sync --hard
    execute_cargo_cmd("mgit", &["sync", &input_path, "--hard"]);

    // ignore "foobar" folder
    std::fs::write(&ignore_file, ingore_content.trim()).expect("Failed to write file .gitignore!");
    // compaire changes after sync
    if let Ok(output) = execute_cmd(&path, "git", &["status"]) {
        assert!(
            output.contains(".gitignore")
                && !output.contains("1.txt")
                && !output.contains(".gitrepos")
        );
    } else {
        panic!("sync error.")
    }

    // clean-up
    std::fs::remove_dir_all(&path).unwrap();
}

pub fn execute_cmd(path: &PathBuf, cmd: &str, args: &[&str]) -> Result<String, anyhow::Error> {
    let output = std::process::Command::new(cmd)
        .current_dir(path.to_path_buf())
        .args(args)
        .stdout(std::process::Stdio::piped())
        .stderr(std::process::Stdio::null())
        .stderr(std::process::Stdio::piped())
        .output()?;
    let stdout = String::from_utf8(output.stdout)?;
    let stderr = String::from_utf8(output.stderr)?;

    match output.status.success() {
        false => Err(anyhow::anyhow!(stderr)),
        true => Ok(stdout),
    }
}

pub fn execute_cargo_cmd(cmd: &str, args: &[&str]) {
    Command::cargo_bin(cmd)
        .unwrap()
        .args(args)
        .assert()
        .success();
}
