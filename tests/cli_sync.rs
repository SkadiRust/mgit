use crate::common::{execute_cargo_cmd, execute_cmd};
use std::env;

mod common;
/// 测试内容：
///     1、运行命令 mgit sync <path>
///     2、批量同步配置文件 (.gitrepos)所有仓库，模拟 git reset --soft 到远端 commit/tag/branch   
///     3、local commit 会还原成 local changes    
///     4、根目录是仓库
///
/// 测试目录结构:
///   test_sync_simple(.git)
///     ├─foobar (.git)
///     └─1.txt
#[test]
fn cli_sync_simple() {
    let path = env::current_dir()
        .unwrap()
        .join("target/tmp/test_sync_simple");
    let input_path = path.to_str().unwrap();

    let _ = std::fs::remove_dir_all(&path);
    std::fs::create_dir_all(&path).unwrap();

    let toml_string = r#"
# This file is automatically @generated by mgit.
# Editing it as you wish.
default-branch = "develop"

[[repos]]
local = "."
remote = "https://gitee.com/mirrors_andygrunwald/rust-hello.git"
commit = "fb3a82a783afc89a2d3f1e40ecbf74a697445e8f"

[[repos]]
local = "foobar"
remote = "https://gitee.com/mirrors_andygrunwald/rust-hello.git"
branch = "master"
"#;
    let config_file = path.join(".gitrepos");
    std::fs::write(&config_file, toml_string.trim()).expect("Failed to write file .gitrepos!");

    // initialize the repositories tree
    ("mgit", &["sync", &input_path, "--hard"]);

    // ignore "foobar" folder
    let ignore_file = path.join(".gitignore");
    let ingore_content = "/target\n/foobar";
    std::fs::write(&ignore_file, ingore_content.trim()).expect("Failed to write file .gitignore!");

    // create new local commit
    std::fs::File::create(path.join("1.txt")).ok();
    let _ = (&path, "git", &["add", "."]);
    let _ = execute_cmd(&path, "git", &["commit", "-am", "foobar"]);

    // if commit succ
    assert!(execute_cmd(&path, "git", &["status"]).is_ok());

    // sync --hard will delete .gitrepos in the front
    std::fs::write(&config_file, toml_string.trim()).expect("Failed to write file .gitrepos!");
    // excute sync
    execute_cargo_cmd("mgit", &["sync", &input_path]);

    // compaire changes after sync
    if let Ok(output) = execute_cmd(&path, "git", &["status"]) {
        assert!(
            output.contains(".gitignore")
                && output.contains("1.txt")
                && output.contains(".gitrepos")
        );
    } else {
        panic!("git status error.")
    }

    // clean-up
    std::fs::remove_dir_all(&path).unwrap();
}

/// 测试内容：
///     1、运行命令 mgit sync <path>
///     2、模拟远端 commit/tag/branch 失效时的情况
///     3、commit 会还原成 local changes    
///     4、根目录是仓库
///
/// 测试目录结构:
///   test_sync_tracking_invalid(.git)
///     ├─foobar (.git)
///     └─1.txt
#[test]
fn cli_sync_simple_tracking_invalid() {
    let path = env::current_dir()
        .unwrap()
        .join("target/tmp/test_sync_simple_tracking_invalid");
    let input_path = path.to_str().unwrap();

    let _ = std::fs::remove_dir_all(&path);
    std::fs::create_dir_all(&path).unwrap();

    let toml_string = r#"
# This file is automatically @generated by mgit.
# Editing it as you wish.
default-branch = "develop"

[[repos]]
local = "."
remote = "https://gitee.com/mirrors_andygrunwald/rust-hello.git"
branch = "master"

[[repos]]
local = "foobar"
remote = "https://gitee.com/mirrors_andygrunwald/rust-hello.git"
branch = "master"
"#;
    let config_file = path.join(".gitrepos");
    std::fs::write(&config_file, toml_string.trim()).expect("Failed to write file .gitrepos!");

    // initialize the repositories tree
    execute_cargo_cmd("mgit", &["sync", &input_path, "--hard"]);

    // ignore "foobar" folder
    let ignore_file = path.join(".gitignore");
    let ingore_content = "/target\n/foobar";
    std::fs::write(&ignore_file, ingore_content.trim()).expect("Failed to write file .gitignore!");

    // create new local commit
    std::fs::File::create(path.join("1.txt")).ok();

    // compaire changes now
    if let Ok(output) = execute_cmd(&path, "git", &["status"]) {
        assert!(output.contains(".gitignore") && output.contains("1.txt"));
    } else {
        panic!("status error.")
    }

    // set invalid branch
    let toml_string = toml_string.replace("master", "invalid-branch");
    // sync --hard will delete .gitrepos in the front
    std::fs::write(&config_file, toml_string.trim()).expect("Failed to write file .gitrepos!");
    // excute sync
    execute_cargo_cmd("mgit", &["sync", &input_path]);

    // compaire changes after sync
    if let Ok(output) = execute_cmd(&path, "git", &["status"]) {
        assert!(output.contains(".gitignore") && output.contains("1.txt"));
    } else {
        panic!("sync error.")
    }

    // clean-up
    std::fs::remove_dir_all(&path).unwrap();
}

/// 测试内容：
///     1、运行命令 mgit sync <path> --stash
///     2、测试 sync 时，先 stash local changes，再 reset 到远端 commit/tag/branch
///     3、根目录是仓库
///
/// 测试目录结构:
///   test_sync_stash(.git)
///     ├─foobar (.git)
///     └─1.txt
#[test]
fn cli_sync_stash() {
    let path = env::current_dir()
        .unwrap()
        .join("target/tmp/test_sync_stash");
    let input_path = path.to_str().unwrap();

    let _ = std::fs::remove_dir_all(&path);
    std::fs::create_dir_all(&path).unwrap();

    let toml_string = r#"
# This file is automatically @generated by mgit.
# Editing it as you wish.
default-branch = "develop"

[[repos]]
local = "."
remote = "https://gitee.com/mirrors_andygrunwald/rust-hello.git"
branch = "master"

[[repos]]
local = "foobar"
remote = "https://gitee.com/mirrors_andygrunwald/rust-hello.git"
branch = "master"
"#;
    let config_file = path.join(".gitrepos");
    std::fs::write(&config_file, toml_string.trim()).expect("Failed to write file .gitrepos!");

    // initialize the repositories tree
    execute_cargo_cmd("mgit", &["sync", &input_path, "--hard"]);

    // ignore "foobar" folder
    let ignore_file = path.join(".gitignore");
    let ingore_content = "/target\n/foobar";
    std::fs::write(&ignore_file, ingore_content.trim()).expect("Failed to write file .gitignore!");

    // create new local commit
    std::fs::File::create(path.join("1.txt")).ok();

    // compaire changes now
    if let Ok(output) = execute_cmd(&path, "git", &["status"]) {
        assert!(output.contains(".gitignore") && output.contains("1.txt"));
    } else {
        panic!("status error.")
    }

    // sync --hard will delete .gitrepos in the front
    std::fs::write(&config_file, toml_string.trim()).expect("Failed to write file .gitrepos!");

    // excute sync
    execute_cargo_cmd("mgit", &["sync", &input_path, "--stash"]);

    // compaire changes after sync
    if let Ok(output) = execute_cmd(&path, "git", &["status"]) {
        assert!(
            !output.contains(".gitignore")
                && !output.contains("1.txt")
                && !output.contains(".gitrepos")
        );
    } else {
        panic!("sync error.")
    }

    // check stash
    if let Ok(output) = execute_cmd(&path, "git", &["stash", "list"]) {
        assert!(output.lines().count() == 1);
    } else {
        panic!("stash error.")
    }

    // pop stash and check file
    if let Ok(output) = execute_cmd(&path, "git", &["stash", "pop"]) {
        assert!(
            output.contains(".gitignore")
                && output.contains("1.txt")
                && output.contains(".gitrepos")
        );
    } else {
        panic!("stash pop error.")
    }

    // clean-up
    std::fs::remove_dir_all(&path).unwrap();
}

/// 测试内容：
///     1、运行命令 mgit sync <path> --stash
///     2、测试远端 commit/tag/branch 失时导致 sync 失败，将 stash 的内容（若有的话）pop 出来
///     3、根目录是仓库
///
/// 测试目录结构:
///   test_sync_stash(.git)
///     ├─foobar (.git)
///     └─1.txt
#[test]
fn cli_sync_stash_tracking_invalid() {
    let path = env::current_dir()
        .unwrap()
        .join("target/tmp/test_sync_stash_tracking_invalid");
    let input_path = path.to_str().unwrap();

    let _ = std::fs::remove_dir_all(&path);
    std::fs::create_dir_all(&path).unwrap();

    let toml_string = r#"
# This file is automatically @generated by mgit.
# Editing it as you wish.
default-branch = "develop"

[[repos]]
local = "."
remote = "https://gitee.com/mirrors_andygrunwald/rust-hello.git"
branch = "master"

[[repos]]
local = "foobar"
remote = "https://gitee.com/mirrors_andygrunwald/rust-hello.git"
branch = "master"
"#;
    let config_file = path.join(".gitrepos");
    std::fs::write(&config_file, toml_string.trim()).expect("Failed to write file .gitrepos!");

    // initialize the repositories tree
    execute_cargo_cmd("mgit", &["sync", &input_path, "--hard"]);

    // ignore "foobar" folder
    let ignore_file = path.join(".gitignore");
    let ingore_content = "/target\n/foobar";
    std::fs::write(&ignore_file, ingore_content.trim()).expect("Failed to write file .gitignore!");

    // create new local commit
    std::fs::File::create(path.join("1.txt")).ok();

    // compaire changes now
    if let Ok(output) = execute_cmd(&path, "git", &["status"]) {
        assert!(output.contains(".gitignore") && output.contains("1.txt"));
    } else {
        panic!("status error.")
    }

    // set invalid branch
    let toml_string = toml_string.replace("master", "invalid-branch");
    // sync --hard will delete .gitrepos in the front
    std::fs::write(&config_file, toml_string.trim()).expect("Failed to write file .gitrepos!");
    // excute sync --stash

    execute_cargo_cmd("mgit", &["sync", &input_path, "--stash"]);

    // compaire changes after sync
    // nothing will be stash
    if let Ok(output) = execute_cmd(&path, "git", &["status"]) {
        assert!(
            output.contains(".gitignore")
                && output.contains(".gitrepos")
                && output.contains("1.txt")
        );
    } else {
        panic!("sync error.")
    }

    // clean-up
    std::fs::remove_dir_all(&path).unwrap();
}

/// cmd: 'mgit sync ./target/tmp/test_sync_hard --hard'
/// 测试内容：
///     1、运行命令 mgit sync <path> --hard
///     2、测试 sync后, 丢弃所有 changes
///     3、根目录是仓库
///
/// 测试目录结构:
///   test_sync_hard(.git)
///     ├─foobar (.git)
///     └─1.txt
#[test]
fn cli_sync_hard() {
    let path = env::current_dir()
        .unwrap()
        .join("target/tmp/test_sync_hard");
    let input_path = path.to_str().unwrap();

    let _ = std::fs::remove_dir_all(&path);
    std::fs::create_dir_all(&path).unwrap();

    let toml_string = r#"
# This file is automatically @generated by mgit.
# Editing it as you wish.
default-branch = "develop"

[[repos]]
local = "."
remote = "https://gitee.com/mirrors_andygrunwald/rust-hello.git"
commit = "fb3a82a783afc89a2d3f1e40ecbf74a697445e8f"

[[repos]]
local = "foobar"
remote = "https://gitee.com/mirrors_andygrunwald/rust-hello.git"
branch = "master"
"#;
    let config_file = path.join(".gitrepos");
    std::fs::write(&config_file, toml_string.trim()).expect("Failed to write file .gitrepos!");

    // initialize the repositories tree
    execute_cargo_cmd("mgit", &["sync", &input_path, "--hard"]);

    // ignore "foobar" folder
    let ignore_file = path.join(".gitignore");
    let ingore_content = "/target\n/foobar";
    std::fs::write(&ignore_file, ingore_content.trim()).expect("Failed to write file .gitignore!");

    // create new local commit
    std::fs::File::create(path.join("1.txt")).ok();
    let _ = execute_cmd(&path, "git", &["add", "."]);
    let _ = execute_cmd(&path, "git", &["commit", "-am", "foobar"]);

    // if commit succ
    assert!(execute_cmd(&path, "git", &["status"]).is_ok());

    // sync --hard will delete .gitrepos in the front
    std::fs::write(&config_file, toml_string.trim()).expect("Failed to write file .gitrepos!");
    // excute sync --hard
    execute_cargo_cmd("mgit", &["sync", &input_path, "--hard"]);

    // ignore "foobar" folder
    std::fs::write(&ignore_file, ingore_content.trim()).expect("Failed to write file .gitignore!");
    // compaire changes after sync
    if let Ok(output) = execute_cmd(&path, "git", &["status"]) {
        assert!(
            output.contains(".gitignore")
                && !output.contains("1.txt")
                && !output.contains(".gitrepos")
        );
    } else {
        panic!("sync error.")
    }

    // clean-up
    std::fs::remove_dir_all(&path).unwrap();
}
