use super::{TomlConfig, TomlRepo};
use globset::GlobBuilder;
use std::collections::BTreeMap;
use std::fs;
use std::path::Path;
use toml_edit;
use walkdir::WalkDir;

pub fn exec(path: Option<String>) {
    let cwd = std::env::current_dir().unwrap();
    let cwd_str = Some(String::from(cwd.to_string_lossy()));
    let input = path.or(cwd_str).unwrap();

    // starting init repos
    println!("init {}", input);
    let input_path = Path::new(&input);

    // check if input is a valid directory
    if input_path.is_dir() == false {
        println!("Invalid input: directory {} not found!", input);
        return;
    }

    // TODO
    // // check if .mgit/ exists
    // let user_dir = input_path.join(".mgit");
    // if user_dir.is_dir() == false {
    // }

    // check if .gitrepos exists
    let config_file = input_path.join(".gitrepos");
    if config_file.is_file() == true {
        println!("The directory {} already inited!", input);
        return;
    }
    let mut toml_config = TomlConfig {
        version: None,
        default_branch: Some(String::from("develop")),
        default_remote: None,
        repos: None,
    };

    // search for git repos and create .gitrepos file
    let glob = GlobBuilder::new("**/.git")
        .literal_separator(true)
        .build()
        .unwrap()
        .compile_matcher();

    println!("search and add git repos:");
    let mut count = 0;
    let mut it = WalkDir::new(input_path).into_iter();
    let mut repos: Vec<TomlRepo> = Vec::new();
    loop {
        let entry = match it.next() {
            None => break,
            Some(Err(err)) => panic!("ERROR: {}", err),
            Some(Ok(entry)) => entry,
        };
        let path = entry.path();

        if glob.is_match(path) {
            // get relative path
            let mut pb = path.to_path_buf();
            pb.pop();
            let rel_path = Path::new(".").join(pb.strip_prefix(input_path).unwrap());
            let norm_path = rel_path
                .into_os_string()
                .into_string()
                .unwrap()
                .replace("\\", "/");

            // DELME:
            // convert project name
            // let name = match rel_path.clone().file_name() {
            //     None => String::from("_"),
            //     Some(p) => p.to_os_string().into_string().unwrap(),
            // };
            // let name2 = name.replace(".", "_");
            // println!("project name = {}", name2);

            // set toml repo
            let toml_repo = TomlRepo {
                local: Some(norm_path.clone()),
                remote: None,
                branch: None,
                tag: None,
                commit: None,
            };
            repos.push(toml_repo);
            println!("add {}", norm_path);

            // just skip go into .git/ folder and continue
            it.skip_current_dir();
            continue;
        }

        count += 1;
    }

    let mut map = BTreeMap::new();
    map.insert(String::from("repos"), repos);
    toml_config.repos = Some(map);
    println!("{} files read!", count);

    // serialize .gitrepos
    let toml_string = serialize_config(&toml_config);
    fs::write(config_file, toml_string).expect("Failed to write file .gitrepos!");
}

// serialzie config file .gitrepos
fn serialize_config(toml_config: &TomlConfig) -> String {
    let toml = toml_edit::ser::to_item(&toml_config).unwrap();
    let mut out = String::new();

    out.push_str("# This file is automatically @generated by mgit.\n");
    out.push_str("# Editing it as you wish.\n");

    // version = "x.y.z"
    if let Some(item) = toml.get("version") {
        out.push_str(&format!("version = {}\n", item));
    }

    // default-branch = "your_branch"
    if let Some(item) = toml.get("default-branch") {
        out.push_str(&format!("default-branch = {}\n", item));
    }

    // default-remote = "your_remote"
    if let Some(item) = toml.get("default-remote") {
        out.push_str(&format!("default-remote = {}\n", item));
    }

    out.push_str("\n");

    // [[repos]]
    if let Some(repos) = toml.get("repos") {
        let table = repos.as_inline_table().expect("repos must be table");
        let list = table.get("repos").unwrap().as_array().expect("repos must be array");

        for entry in list {
            out.push_str("[[repos]]\n");
            let table = entry.as_inline_table().expect("repo must be table");

            // local = "your/local/path"
            if let Some(item) = table.get("local") {
                out.push_str(&format!("local = {}\n", item));
            }

            // remote = "your://remote/url"
            if let Some(item) = table.get("remote") {
                out.push_str(&format!("remote = {}\n", item));
            }

            // branch = "your_branch"
            if let Some(item) = table.get("branch") {
                out.push_str(&format!("branch = {}\n", item));
            }

            // tag = "your_tag"
            if let Some(item) = table.get("tag") {
                out.push_str(&format!("tag = {}\n", item));
            }

            // commit = "your_tag"
            if let Some(item) = table.get("commit") {
                out.push_str(&format!("commit = {}\n", item));
            }

            out.push_str("\n");
        }
    }

    out
}
