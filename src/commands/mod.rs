use anyhow::Context;
use console::{strip_ansi_codes, truncate_str};
use indicatif::ProgressBar;
use owo_colors::OwoColorize;
use regex::Regex;
use serde::{Deserialize, Serialize};
use std::collections::HashSet;
use std::fs;
use std::io::{BufRead, BufReader};
use std::path::{Path, PathBuf};
use std::process::{Command, Stdio};
use toml_edit;

pub mod clean;
pub mod fetch;
pub mod snapshot;
pub mod sync;
pub mod track;

#[derive(PartialEq)]
pub enum StashMode {
    Normal,
    Stash,
    Hard,
}

pub enum ResetType {
    Soft,
    Mixed,
    Hard,
}
pub enum SnapshotType {
    Commit,
    Branch,
}

/// this type is used to deserialize `.gitrepos` files.
#[derive(Serialize, Deserialize, Debug)]
#[serde(rename_all = "kebab-case")]
pub struct TomlConfig {
    version: Option<String>,
    default_branch: Option<String>,
    default_remote: Option<String>,
    repos: Option<Vec<TomlRepo>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
#[serde(rename_all = "kebab-case")]
pub struct TomlRepo {
    local: Option<String>,
    remote: Option<String>,
    branch: Option<String>,
    tag: Option<String>,
    commit: Option<String>,
}

impl TomlConfig {
    // serialzie config file .gitrepos
    pub fn serialize(&self) -> String {
        let toml = toml_edit::ser::to_item(self).unwrap();
        let mut out = String::new();

        out.push_str("# This file is automatically @generated by mgit.\n");
        out.push_str("# Editing it as you wish.\n");

        // version = "x.y.z"
        if let Some(item) = toml.get("version") {
            out.push_str(&format!("version = {}\n", item));
        }

        // default-branch = "your_branch"
        if let Some(item) = toml.get("default-branch") {
            out.push_str(&format!("default-branch = {}\n", item));
        }

        // default-remote = "your_remote"
        if let Some(item) = toml.get("default-remote") {
            out.push_str(&format!("default-remote = {}\n", item));
        }

        out.push_str("\n");

        // [[repos]]
        if let Some(repos) = toml.get("repos") {
            let list = repos.as_array().expect("repos must be an array");

            for entry in list {
                out.push_str("[[repos]]\n");
                let table = entry.as_inline_table().expect("repo must be table");

                // local = "your/local/path"
                if let Some(item) = table.get("local") {
                    out.push_str(&format!("local = {}\n", item));
                }

                // remote = "your://remote/url"
                if let Some(item) = table.get("remote") {
                    out.push_str(&format!("remote = {}\n", item));
                }

                // branch = "your_branch"
                if let Some(item) = table.get("branch") {
                    out.push_str(&format!("branch = {}\n", item));
                }

                // tag = "your_tag"
                if let Some(item) = table.get("tag") {
                    out.push_str(&format!("tag = {}\n", item));
                }

                // commit = "your_tag"
                if let Some(item) = table.get("commit") {
                    out.push_str(&format!("commit = {}\n", item));
                }

                out.push_str("\n");
            }
        }

        out
    }
}

/// normalize path if needed
pub fn norm_path(path: &String) -> String {
    path.replace("\\", "/")
}

/// if path is empty, represent it by "."
pub fn display_path(path: &String) -> String {
    match path.is_empty() {
        true => String::from("."),
        false => path.clone(),
    }
}

// deserialize config file (.gitrepos) with full file path
pub fn load_config(config_file: &PathBuf) -> Option<TomlConfig> {
    if config_file.is_file() {
        // mac not recognize "."
        let txt = fs::read_to_string(config_file)
            .unwrap()
            .replace("\".\"", "\"\"");

        let toml_config: TomlConfig = toml::from_str(txt.as_str()).unwrap();

        return Some(toml_config);
    }
    None
}

pub fn is_repository(path: &Path) -> Result<(), anyhow::Error> {
    match path.join(".git").is_dir() {
        true => Ok(()),
        false => Err(anyhow::anyhow!("repository not found!")),
    }
}

pub fn find_remote_name_by_url(path: &Path, url: &String) -> Result<String, anyhow::Error> {
    is_repository(path)?;
    let args = ["remote", "-v"];
    let output = execute_cmd(path, "git", &args)?;

    for line in output.trim().lines() {
        if line.contains(url) {
            if let Some(remote_name) = line.split(url).next() {
                return Ok(remote_name.trim().to_string());
            }
        }
    }

    Err(anyhow::anyhow!("remote {} not found.", url.blue()))
}

pub fn find_remote_url_by_name(path: &Path, name: &String) -> Result<String, anyhow::Error> {
    is_repository(path)?;
    let args = ["remote", "get-url", &name];
    let output = execute_cmd(path, "git", &args)?;

    for remote_url in output.trim().lines() {
        return Ok(remote_url.trim().to_string());
    }

    Err(anyhow::anyhow!("remote {} not found.", name.blue()))
}

pub fn get_current_commit(path: &Path) -> Result<String, anyhow::Error> {
    is_repository(path)?;
    let args = ["rev-parse", "Head"];
    let output = execute_cmd(path, "git", &args)?;

    for oid in output.trim().lines() {
        return Ok(oid.to_string());
    }

    Err(anyhow::anyhow!("current commit not found."))
}

pub fn get_tracking_branch(path: &Path) -> Result<String, anyhow::Error> {
    is_repository(path)?;
    let args = ["branch", "-vv"];
    let output = execute_cmd(path, "git", &args)?;

    for line in output.trim().lines() {
        let re = Regex::new(r"\*([^\[]+)\[(?P<refname>[^\]\:]+)([^\]]*)\]").unwrap();
        if let Some(caps) = re.captures(line) {
            let refname = &caps["refname"];
            if let Some(branch) = refname.split("origin/").last() {
                return Ok(branch.trim().to_string());
            }
        }
    }

    Err(anyhow::anyhow!("untracked."))
}

pub fn get_current_branch(path: &Path) -> Result<String, anyhow::Error> {
    is_repository(path)?;
    let args = ["branch", "--show-current"];
    let output = execute_cmd(path, "git", &args)?;
    for line in output.trim().lines() {
        return Ok(line.to_string());
    }
    Err(anyhow::anyhow!("current branch not found."))
}

/// get full ahead/behind values between branches
pub fn cmp_local_remote(
    input_path: &Path,
    toml_repo: &TomlRepo,
    default_branch: &Option<String>,
) -> Result<Option<String>, anyhow::Error> {
    let rel_path = toml_repo.local.as_ref().unwrap();
    let full_path = input_path.join(rel_path);

    // priority: commit/tag/branch/default-branch
    let (remote_ref, remote_desc) = {
        if let Some(commit) = &toml_repo.commit {
            (commit.clone(), (&commit[..7]).to_string())
        } else if let Some(tag) = &toml_repo.tag {
            (tag.clone(), tag.clone())
        } else if let Some(branch) = toml_repo.clone().branch {
            let branch = "origin/".to_string() + &branch;
            (branch.clone(), branch)
        } else if let Some(branch) = default_branch {
            let branch = "origin/".to_string() + &branch;
            (branch.clone(), branch.clone())
        } else {
            (String::new(), String::new())
        }
    };

    // if specified remote commit/tag/branch is null
    if remote_desc.is_empty() {
        return Ok(Some("not tracking".to_string()));
    }

    let mut changed_files: HashSet<String> = HashSet::new();

    // get untracked files (uncommit)
    let args = ["ls-files", ".", "--exclude-standard", "--others"];
    if let Ok(output) = execute_cmd(&full_path, "git", &args) {
        for file in output.trim().lines() {
            changed_files.insert(file.to_string());
        }
    }

    // get tracked and changed files (uncommit)
    let args = ["diff", "--name-only"];
    if let Ok(output) = execute_cmd(&full_path, "git", &args) {
        for file in output.trim().lines() {
            changed_files.insert(file.to_string());
        }
    }

    // get cached(staged) files (uncommit)
    let args = ["diff", "--cached", "--name-only"];
    if let Ok(output) = execute_cmd(&full_path, "git", &args) {
        for file in output.trim().lines() {
            changed_files.insert(file.to_string());
        }
    }

    let mut changes_desc = String::new();
    if changed_files.is_empty() == false {
        // format changes tooltip
        changes_desc = ", ".to_string()
            + &format!("changes({})", changed_files.len())
                .red()
                .to_string();
    }

    // get local branch
    let branch = get_current_branch(full_path.as_path())?;

    if branch.is_empty() {
        return Ok(Some("init commit".to_string()));
    }

    // get rev-list between local branch and specified remote commit/tag/branch
    let branch_pair = format!("{}...{}", &branch, &remote_ref);
    let args = ["rev-list", "--count", "--left-right", &branch_pair];
    let mut commit_desc = String::new();
    if let Ok(output) = execute_cmd(&full_path, "git", &args) {
        let re = Regex::new(r"(\d+)\s*(\d+)").unwrap();

        if let Some(caps) = re.captures(&output) {
            // format commit tooltip
            let (ahead, begind) = (&caps[1], &caps[2]);
            commit_desc = match (ahead, begind) {
                ("0", "0") => String::new(),
                (_, "0") => {
                    String::from(", ") + &format!("commits({}↑)", &caps[1]).yellow().to_string()
                }
                ("0", _) => {
                    String::from(", ") + &format!("commits({}↓)", &caps[2]).yellow().to_string()
                }
                _ => {
                    String::from(", ")
                        + &format!("commits({}↑{}↓)", &caps[1], &caps[2])
                            .yellow()
                            .to_string()
                }
            };
        }
    } else {
        // if git rev-list find "unknown revision" error
        commit_desc = format!(", {}", "unknown revision".yellow());
    }

    // show diff overview
    let desc = if commit_desc.is_empty() && changes_desc.is_empty() {
        "already update to date".to_string()
    } else {
        format!("{}{}{}", remote_desc.blue(), commit_desc, changes_desc,)
    };

    Ok(Some(desc))
}

pub fn execute_cmd(path: &Path, cmd: &str, args: &[&str]) -> Result<String, anyhow::Error> {
    let mut command = std::process::Command::new(cmd);
    let full_command = command.current_dir(path.to_path_buf()).args(args);

    let output = full_command
        .stdout(std::process::Stdio::piped())
        .stderr(std::process::Stdio::piped())
        .output()
        .with_context(|| format!("Error starting command: {:?}", full_command))?;

    let stdout = String::from_utf8(output.stdout)?;
    let stderr = String::from_utf8(output.stderr)?;

    match output.status.success() {
        true => Ok(stdout),
        false => Err(anyhow::anyhow!(stderr)),
    }
}

fn execute_cmd_with_progress(
    rel_path: &String,
    command: &mut Command,
    prefix: &str,
    progress_bar: &ProgressBar,
) -> anyhow::Result<()> {
    let mut spawned = command
        .stdin(Stdio::null())
        .stdout(Stdio::piped())
        .stderr(Stdio::piped())
        .spawn()
        .with_context(|| format!("Error starting command {:?}", command))?;

    let mut last_line = format!(
        "{:>9} {}: running...",
        prefix,
        display_path(rel_path).bold().magenta()
    );
    progress_bar.set_message(last_line.clone());

    // get message from stderr with "--progress" option
    if let Some(ref mut stderr) = spawned.stderr {
        let lines = BufReader::new(stderr).split(b'\r');
        for line in lines {
            let output = line.unwrap();
            if output.is_empty() {
                continue;
            }
            let line = std::str::from_utf8(&output).unwrap();
            let plain_line = strip_ansi_codes(line).replace('\n', " ");
            let full_line = format!(
                "{:>9} {}: {}",
                prefix,
                display_path(rel_path).bold().magenta(),
                plain_line.trim()
            );
            let truncated_line = truncate_str(&full_line, 70, "...");
            progress_bar.set_message(format!("{}", truncated_line));
            last_line = plain_line;
        }
    }

    let exit_code = spawned
        .wait()
        .context("Error waiting for process to finish")?;

    if exit_code.success() == false {
        return Err(anyhow::anyhow!(
            "Git exited with code {}: {}. With command : {:?}.",
            exit_code.code().unwrap(),
            last_line.trim(),
            command
        ));
    }

    Ok(())
}
