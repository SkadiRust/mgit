use crate::common::{exec_cargo_cmd, exec_cmd, failed_message};
use std::{collections::HashSet, env, path::PathBuf};

mod common;

/// 测试内容：
///     1、运行命令 mgit sync <path> --no-checkout
///     2、批量同步配置文件 (.gitrepos)所有仓库，模拟 git reset --soft 到远端 commit/tag/branch
///     3、local commit 会还原成 local changes
///     4、根目录是仓库
///
/// 测试目录结构:
///   test_sync_simple(.git)
///     ├─foobar (.git)
///     └─1.txt
#[test]
fn cli_sync_simple() {
    let path = env::current_dir()
        .unwrap()
        .join("target/tmp/test_sync_simple");
    let input_path = path.to_str().unwrap();

    let _ = std::fs::remove_dir_all(&path);
    std::fs::create_dir_all(&path).unwrap();

    let toml_string = r#"
# This file is automatically @generated by mgit.
# Editing it as you wish.
default-branch = "develop"

[[repos]]
local = "."
remote = "https://gitee.com/ForthEspada/CS-Books.git"
commit = "fc8ba56c64b7b7e4dd2d171fd95ca620aa36d695"

[[repos]]
local = "foobar"
remote = "https://gitee.com/ForthEspada/CS-Books.git"
branch = "master"
"#;
    let config_file = path.join(".gitrepos");
    std::fs::write(&config_file, toml_string.trim()).expect(failed_message::WRITE_FILE);

    // initialize the repositories tree
    exec_cargo_cmd("mgit", &["sync", &input_path, "--hard", "--no-checkout"]);

    // ignore "foobar" folder
    let ignore_file = path.join(".gitignore");
    let ingore_content = "/target\n/foobar";
    std::fs::write(&ignore_file, ingore_content.trim()).expect(failed_message::WRITE_FILE);

    // create new local commit
    std::fs::File::create(path.join("1.txt")).ok();
    let _ = exec_cmd(&path, "git", &["add", ".", "-f"]);
    check_git_author_identity(&path);
    let _ = exec_cmd(&path, "git", &["commit", "-am", "foobar"]);

    // if commit succ
    assert!(exec_cmd(&path, "git", &["status"]).is_ok());

    // sync --hard will delete .gitrepos in the front
    std::fs::write(&config_file, toml_string.trim()).expect(failed_message::WRITE_FILE);
    // excute sync
    exec_cargo_cmd("mgit", &["sync", &input_path, "--no-checkout"]);

    // compaire changes after sync
    if let Ok(output) = exec_cmd(&path, "git", &["status"]) {
        assert!(output.contains(".gitignore"));
        assert!(output.contains(".gitrepos"));
        assert!(output.contains("1.txt"));
    } else {
        panic!("{}", failed_message::GIT_STATUS);
    }

    // clean-up
    std::fs::remove_dir_all(&path).unwrap();
}

/// 测试内容：
///     1、运行命令 mgit sync <path> --no-checkout
///     2、模拟远端 commit/tag/branch 失效时的情况
///     3、commit 会还原成 local changes
///     4、根目录是仓库
///
/// 测试目录结构:
///   test_sync_tracking_invalid(.git)
///     ├─foobar (.git)
///     └─1.txt
#[test]
fn cli_sync_simple_tracking_invalid() {
    let path = env::current_dir()
        .unwrap()
        .join("target/tmp/test_sync_simple_tracking_invalid");
    let input_path = path.to_str().unwrap();

    let _ = std::fs::remove_dir_all(&path);
    std::fs::create_dir_all(&path).unwrap();

    let toml_string = r#"
# This file is automatically @generated by mgit.
# Editing it as you wish.
default-branch = "develop"

[[repos]]
local = "."
remote = "https://gitee.com/ForthEspada/CS-Books.git"
branch = "master"

[[repos]]
local = "foobar"
remote = "https://gitee.com/ForthEspada/CS-Books.git"
branch = "master"
"#;
    let config_file = path.join(".gitrepos");
    std::fs::write(&config_file, toml_string.trim()).expect(failed_message::WRITE_FILE);

    // initialize the repositories tree
    exec_cargo_cmd("mgit", &["sync", &input_path, "--hard"]);

    // ignore "foobar" folder
    let ignore_file = path.join(".gitignore");
    let ingore_content = "/target\n/foobar";
    std::fs::write(&ignore_file, ingore_content.trim()).expect(failed_message::WRITE_FILE);

    // create new local commit
    std::fs::File::create(path.join("1.txt")).ok();

    // compaire changes now
    if let Ok(output) = exec_cmd(&path, "git", &["status"]) {
        assert!(output.contains(".gitignore"));
        assert!(output.contains("1.txt"));
    } else {
        panic!("{}", failed_message::GIT_STATUS);
    }

    // set invalid branch
    let toml_string = toml_string.replace("master", "invalid-branch");
    // sync --hard will delete .gitrepos in the front
    std::fs::write(&config_file, toml_string.trim()).expect(failed_message::WRITE_FILE);
    // excute sync
    exec_cargo_cmd("mgit", &["sync", &input_path, "--no-checkout"]);

    // compaire changes after sync
    if let Ok(output) = exec_cmd(&path, "git", &["status"]) {
        assert!(output.contains(".gitignore"));
        assert!(output.contains("1.txt"));
    } else {
        panic!("{}", failed_message::GIT_STATUS);
    }

    // clean-up
    std::fs::remove_dir_all(&path).unwrap();
}

/// 测试内容：
///     1、运行命令 mgit sync <path> --stash
///     2、测试 sync 时，先 stash local changes，再 reset 到远端 commit/tag/branch
///     3、根目录是仓库
///
/// 测试目录结构:
///   test_sync_stash(.git)
///     ├─foobar (.git)
///     └─1.txt
#[test]
fn cli_sync_stash() {
    let path = env::current_dir()
        .unwrap()
        .join("target/tmp/test_sync_stash");
    let input_path = path.to_str().unwrap();

    let _ = std::fs::remove_dir_all(&path);
    std::fs::create_dir_all(&path).unwrap();

    let toml_string = r#"
# This file is automatically @generated by mgit.
# Editing it as you wish.
default-branch = "develop"

[[repos]]
local = "."
remote = "https://gitee.com/ForthEspada/CS-Books.git"
branch = "master"

[[repos]]
local = "foobar"
remote = "https://gitee.com/ForthEspada/CS-Books.git"
branch = "master"
"#;
    let config_file = path.join(".gitrepos");
    std::fs::write(&config_file, toml_string.trim()).expect(failed_message::WRITE_FILE);

    // initialize the repositories tree
    exec_cargo_cmd("mgit", &["sync", &input_path, "--hard"]);

    // ignore "foobar" folder
    let ignore_file = path.join(".gitignore");
    let ingore_content = "/target\n/foobar";
    std::fs::write(&ignore_file, ingore_content.trim()).expect(failed_message::WRITE_FILE);

    // create new local commit
    std::fs::File::create(path.join("1.txt")).ok();

    // compaire changes now
    if let Ok(output) = exec_cmd(&path, "git", &["status"]) {
        assert!(output.contains(".gitignore"));
        assert!(output.contains("1.txt"))
    } else {
        panic!("{}", failed_message::GIT_STATUS);
    }

    // sync --hard will delete .gitrepos in the front
    std::fs::write(&config_file, toml_string.trim()).expect(failed_message::WRITE_FILE);

    // excute sync
    exec_cargo_cmd("mgit", &["sync", &input_path, "--stash", "--no-checkout"]);

    // compaire changes after sync
    if let Ok(output) = exec_cmd(&path, "git", &["status"]) {
        assert_eq!(false, output.contains(".gitignore"));
        assert_eq!(false, output.contains(".gitrepos"));
        assert_eq!(false, output.contains("1.txt"));
    } else {
        panic!("{}", failed_message::GIT_STATUS);
    }

    // check stash
    if let Ok(output) = exec_cmd(&path, "git", &["stash", "list"]) {
        assert_eq!(1, output.lines().count());
    } else {
        panic!("{}", failed_message::GIT_STASH_LIST);
    }

    // pop stash and check file
    if let Ok(output) = exec_cmd(&path, "git", &["stash", "pop"]) {
        assert!(output.contains(".gitignore"));
        assert!(output.contains(".gitrepos"));
        assert!(output.contains("1.txt"));
    } else {
        panic!("{}", failed_message::GIT_STASH_POP);
    }

    // clean-up
    std::fs::remove_dir_all(&path).unwrap();
}

/// 测试内容：
///     1、运行命令 mgit sync <path> --stash
///     2、测试远端 commit/tag/branch 失时导致 sync 失败，将 stash 的内容（若有的话）pop 出来
///     3、根目录是仓库
///
/// 测试目录结构:
///   test_sync_stash(.git)
///     ├─foobar (.git)
///     └─1.txt
#[test]
fn cli_sync_stash_tracking_invalid() {
    let path = env::current_dir()
        .unwrap()
        .join("target/tmp/test_sync_stash_tracking_invalid");
    let input_path = path.to_str().unwrap();

    let _ = std::fs::remove_dir_all(&path);
    std::fs::create_dir_all(&path).unwrap();

    let toml_string = r#"
# This file is automatically @generated by mgit.
# Editing it as you wish.
default-branch = "develop"

[[repos]]
local = "."
remote = "https://gitee.com/ForthEspada/CS-Books.git"
branch = "master"

[[repos]]
local = "foobar"
remote = "https://gitee.com/ForthEspada/CS-Books.git"
branch = "master"
"#;
    let config_file = path.join(".gitrepos");
    std::fs::write(&config_file, toml_string.trim()).expect(failed_message::WRITE_FILE);

    // initialize the repositories tree
    exec_cargo_cmd("mgit", &["sync", &input_path, "--hard"]);

    // ignore "foobar" folder
    let ignore_file = path.join(".gitignore");
    let ingore_content = "/target\n/foobar";
    std::fs::write(&ignore_file, ingore_content.trim()).expect(failed_message::WRITE_FILE);

    // create new local commit
    std::fs::File::create(path.join("1.txt")).ok();

    // compaire changes now
    if let Ok(output) = exec_cmd(&path, "git", &["status"]) {
        assert!(output.contains(".gitignore"));
        assert!(output.contains("1.txt"));
    } else {
        panic!("{}", failed_message::GIT_STATUS);
    }

    // set invalid branch
    let toml_string = toml_string.replace("master", "invalid-branch");
    // sync --hard will delete .gitrepos in the front
    std::fs::write(&config_file, toml_string.trim()).expect(failed_message::WRITE_FILE);
    // excute sync --stash

    exec_cargo_cmd("mgit", &["sync", &input_path, "--stash", "--no-checkout"]);

    // compaire changes after sync
    // nothing will be stash
    if let Ok(output) = exec_cmd(&path, "git", &["status"]) {
        assert!(output.contains(".gitignore"));
        assert!(output.contains(".gitrepos"));
        assert!(output.contains("1.txt"));
    } else {
        panic!("{}", failed_message::GIT_STATUS);
    }

    // clean-up
    std::fs::remove_dir_all(&path).unwrap();
}

/// 测试内容：
///     1、运行命令 mgit sync <path> --hard
///     2、测试 sync后, 丢弃所有 changes
///     3、根目录是仓库
///
/// 测试目录结构:
///   test_sync_hard(.git)
///     ├─foobar (.git)
///     └─1.txt
#[test]
fn cli_sync_hard() {
    let path = env::current_dir()
        .unwrap()
        .join("target/tmp/test_sync_hard");
    let input_path = path.to_str().unwrap();

    let _ = std::fs::remove_dir_all(&path);
    std::fs::create_dir_all(&path).unwrap();

    let toml_string = r#"
# This file is automatically @generated by mgit.
# Editing it as you wish.
default-branch = "develop"

[[repos]]
local = "."
remote = "https://gitee.com/ForthEspada/CS-Books.git"
commit = "fc8ba56c64b7b7e4dd2d171fd95ca620aa36d695"

[[repos]]
local = "foobar"
remote = "https://gitee.com/ForthEspada/CS-Books.git"
branch = "master"
"#;
    let config_file = path.join(".gitrepos");
    std::fs::write(&config_file, toml_string.trim()).expect(failed_message::WRITE_FILE);

    // initialize the repositories tree
    exec_cargo_cmd("mgit", &["sync", &input_path, "--hard"]);

    // ignore "foobar" folder
    let ignore_file = path.join(".gitignore");
    let ingore_content = "/target\n/foobar";
    std::fs::write(&ignore_file, ingore_content.trim()).expect(failed_message::WRITE_FILE);

    // create new local commit
    std::fs::File::create(path.join("1.txt")).ok();
    let _ = exec_cmd(&path, "git", &["add", ".", "-f"]);
    check_git_author_identity(&path);
    let _ = exec_cmd(&path, "git", &["commit", "-am", "foobar"]);

    // if commit succ
    assert!(exec_cmd(&path, "git", &["status"]).is_ok());

    // sync --hard will delete .gitrepos in the front
    std::fs::write(&config_file, toml_string.trim()).expect(failed_message::WRITE_FILE);
    // excute sync --hard
    exec_cargo_cmd("mgit", &["sync", &input_path, "--hard", "--no-checkout"]);

    // ignore "foobar" folder
    std::fs::write(&ignore_file, ingore_content.trim()).expect(failed_message::WRITE_FILE);
    // compaire changes after sync
    if let Ok(output) = exec_cmd(&path, "git", &["status"]) {
        assert!(output.contains(".gitignore"));
        assert_eq!(false, output.contains(".gitrepos"));
        assert_eq!(false, output.contains("1.txt"));
    } else {
        panic!("{}", failed_message::GIT_STATUS);
    }

    // clean-up
    std::fs::remove_dir_all(&path).unwrap();
}

/// 测试内容：
///     1、运行命令 mgit sync <path> --config
///     2、path 指向的目录不存在时，自动创建目录
///     3、sync 后，changes 数量为 0
///     4、根目录是仓库
///
/// 测试目录结构:
///   test_sync_simple_invalid_path
///     ├─.gitrepos
///     └─foobar-1
///         ├─foobar-1-1 (.git)
///         └─1.txt
#[test]
fn cli_sync_simple_invalid_path() {
    let path = env::current_dir()
        .unwrap()
        .join("target/tmp/test_sync_simple_invalid_path");

    let _ = std::fs::remove_dir_all(&path);
    std::fs::create_dir_all(&path).unwrap();

    let input_path = path.join("foobar-1");

    let toml_string = r#"
# This file is automatically @generated by mgit.
# Editing it as you wish.
default-branch = "develop"

[[repos]]
local = "."
remote = "https://gitee.com/ForthEspada/CS-Books.git"
commit = "fc8ba56c64b7b7e4dd2d171fd95ca620aa36d695"

[[repos]]
local = "foobar-1-1"
remote = "https://gitee.com/ForthEspada/CS-Books.git"
branch = "master"
"#;

    let config_file = path.join(".gitrepos");
    std::fs::write(&config_file, toml_string.trim()).expect(failed_message::WRITE_FILE);
    assert!(config_file.is_file());
    assert_eq!(false, input_path.is_dir());

    // initialize the repositories tree
    exec_cargo_cmd(
        "mgit",
        &[
            "sync",
            input_path.to_str().unwrap(),
            "--config",
            config_file.to_str().unwrap(),
        ],
    );

    assert!(input_path.is_dir());

    let _ = exec_cmd(&path, "git", &["add", ".", "-f"]);

    // ignore "foobar" folder
    let ignore_file = input_path.join(".gitignore");
    let ingore_content = "/target\n/foobar-1-1";
    std::fs::write(&ignore_file, ingore_content.trim()).expect(failed_message::WRITE_FILE);

    // for foobar-1, local changes only contain ".gitignore"
    let local_changes1 = get_local_changes(&input_path);

    assert_eq!(1, local_changes1.len());
    assert!(local_changes1.contains(".gitignore"));

    // for foobar-1/foobar-1-1, local changes is empty
    let local_changes2 = get_local_changes(&input_path.join("foobar-1-1"));
    assert!(local_changes2.is_empty());

    // clean-up
    std::fs::remove_dir_all(&path).unwrap();
}

/// 测试内容：
///     1、运行命令 mgit sync <path> --config --stash
///     2、path 指向的目录不存在时，自动创建目录
///     3、sync 后，changes 数量为 0
///     4、根目录是仓库
///
/// 测试目录结构:
///   test_sync_stash_invalid_path
///     ├─.gitrepos
///     └─foobar-1
///         ├─foobar-1-1 (.git)
///         └─1.txt
#[test]
fn cli_sync_stash_invalid_path() {
    let path = env::current_dir()
        .unwrap()
        .join("target/tmp/test_sync_stash_invalid_path");

    let _ = std::fs::remove_dir_all(&path);
    std::fs::create_dir_all(&path).unwrap();

    let input_path = path.join("foobar-1");

    let toml_string = r#"
# This file is automatically @generated by mgit.
# Editing it as you wish.
default-branch = "develop"

[[repos]]
local = "."
remote = "https://gitee.com/ForthEspada/CS-Books.git"
commit = "fc8ba56c64b7b7e4dd2d171fd95ca620aa36d695"

[[repos]]
local = "foobar-1-1"
remote = "https://gitee.com/ForthEspada/CS-Books.git"
branch = "master"
"#;

    let config_file = path.join(".gitrepos");
    std::fs::write(&config_file, toml_string.trim()).expect(failed_message::WRITE_FILE);
    assert!(config_file.is_file());
    assert_eq!(false, input_path.is_dir());

    // initialize the repositories tree
    exec_cargo_cmd(
        "mgit",
        &[
            "sync",
            input_path.to_str().unwrap(),
            "--config",
            config_file.to_str().unwrap(),
            "--stash",
        ],
    );
    assert!(input_path.is_dir());

    let _ = exec_cmd(&path, "git", &["add", ".", "-f"]);

    // ignore "foobar" folder
    let ignore_file = input_path.join(".gitignore");
    let ingore_content = "/target\n/foobar-1-1";
    std::fs::write(&ignore_file, ingore_content.trim()).expect(failed_message::WRITE_FILE);

    // for foobar-1, local changes only contain ".gitignore"
    let local_changes1 = get_local_changes(&input_path);
    assert_eq!(1, local_changes1.len());
    assert!(local_changes1.contains(".gitignore"));

    // for foobar-1/foobar-1-1, local changes is empty
    let local_changes2 = get_local_changes(&input_path.join("foobar-1-1"));
    assert!(local_changes2.is_empty());

    // clean-up
    std::fs::remove_dir_all(&path).unwrap();
}

/// 测试内容：
///     1、运行命令 mgit sync <path> --config --hard
///     2、path 指向的目录不存在时，自动创建目录
///     3、sync 后，changes 数量为 0
///     4、根目录是仓库
///
/// 测试目录结构:
///   test_sync_hard_invalid_path
///     ├─.gitrepos
///     └─foobar-1
///         ├─foobar-1-1 (.git)
///         └─1.txt
#[test]
fn cli_sync_hard_invalid_path() {
    let path = env::current_dir()
        .unwrap()
        .join("target/tmp/test_sync_hard_invalid_path");

    let _ = std::fs::remove_dir_all(&path);
    std::fs::create_dir_all(&path).unwrap();

    let input_path = path.join("foobar-1");

    let toml_string = r#"
# This file is automatically @generated by mgit.
# Editing it as you wish.
default-branch = "develop"

[[repos]]
local = "."
remote = "https://gitee.com/ForthEspada/CS-Books.git"
commit = "fc8ba56c64b7b7e4dd2d171fd95ca620aa36d695"

[[repos]]
local = "foobar-1-1"
remote = "https://gitee.com/ForthEspada/CS-Books.git"
branch = "master"
"#;

    let config_file = path.join(".gitrepos");
    std::fs::write(&config_file, toml_string.trim()).expect(failed_message::WRITE_FILE);
    assert!(config_file.is_file());
    assert_eq!(false, input_path.is_dir());

    // initialize the repositories tree
    exec_cargo_cmd(
        "mgit",
        &[
            "sync",
            input_path.to_str().unwrap(),
            "--config",
            config_file.to_str().unwrap(),
            "--hard",
        ],
    );
    assert!(input_path.is_dir());

    let _ = exec_cmd(&path, "git", &["add", ".", "-f"]);

    // ignore "foobar" folder
    let ignore_file = input_path.join(".gitignore");
    let ingore_content = "/target\n/foobar-1-1";
    std::fs::write(&ignore_file, ingore_content.trim()).expect(failed_message::WRITE_FILE);

    // for foobar-1, local changes only contain ".gitignore"
    let local_changes1 = get_local_changes(&input_path);
    assert_eq!(1, local_changes1.len());
    assert!(local_changes1.contains(".gitignore"));

    // for foobar-1/foobar-1-1, local changes is empty
    let local_changes2 = get_local_changes(&input_path.join("foobar-1-1"));
    assert!(local_changes2.is_empty());

    // clean-up
    std::fs::remove_dir_all(&path).unwrap();
}

/// get local changes
fn get_local_changes(input_path: &PathBuf) -> HashSet<String> {
    let mut changed_files: HashSet<String> = HashSet::new();

    // get untracked files (uncommit)
    let args = ["ls-files", ".", "--exclude-standard", "--others"];
    if let Ok(output) = exec_cmd(input_path, "git", &args) {
        for file in output.trim().lines() {
            changed_files.insert(file.to_string());
        }
    }

    // get tracked and changed files (uncommit)
    let args = ["diff", "--name-only"];
    if let Ok(output) = exec_cmd(input_path, "git", &args) {
        for file in output.trim().lines() {
            changed_files.insert(file.to_string());
        }
    }

    // get cached(staged) files (uncommit)
    let args = ["diff", "--cached", "--name-only"];
    if let Ok(output) = exec_cmd(input_path, "git", &args) {
        for file in output.trim().lines() {
            changed_files.insert(file.to_string());
        }
    }

    changed_files
}

/// 测试内容：
///     1、运行命令 mgit sync <path> --config
///     2、path 指向的目录存在, 但仓库不存在
///     3、sync 后，changes 数量为 0
///     4、根目录是仓库
///
/// 测试目录结构:
///   cli_sync_simple_repo_invalid
///     ├─.gitrepos
///     └─foobar-1
///         ├─foobar-1-1 (.git)
///         └─1.txt
#[test]
fn cli_sync_simple_repo_invalid() {
    let path = env::current_dir()
        .unwrap()
        .join("target/tmp/test_sync_simple_repo_invalid");

    let _ = std::fs::remove_dir_all(&path);
    std::fs::create_dir_all(&path).unwrap();

    let input_path = path.join("foobar-1");

    let toml_string = r#"
# This file is automatically @generated by mgit.
# Editing it as you wish.
default-branch = "develop"

[[repos]]
local = "."
remote = "https://gitee.com/ForthEspada/CS-Books.git"
commit = "fc8ba56c64b7b7e4dd2d171fd95ca620aa36d695"

[[repos]]
local = "foobar-1-1"
remote = "https://gitee.com/ForthEspada/CS-Books.git"
branch = "master"
"#;

    let config_file = path.join(".gitrepos");
    std::fs::write(&config_file, toml_string.trim()).expect(failed_message::WRITE_FILE);
    assert!(config_file.is_file());
    assert_eq!(false, input_path.is_dir());

    // create root path: "foobar-1"
    std::fs::create_dir_all(&input_path).unwrap();
    assert!(input_path.is_dir());

    // create path: "foobar-1/foobar-1-1"
    std::fs::create_dir_all(&input_path.join("foobar-1-1")).unwrap();
    assert!(input_path.is_dir());

    // initialize the repositories tree
    exec_cargo_cmd(
        "mgit",
        &[
            "sync",
            input_path.to_str().unwrap(),
            "--config",
            config_file.to_str().unwrap(),
        ],
    );

    assert!(input_path.is_dir());

    let _ = exec_cmd(&path, "git", &["add", ".", "-f"]);
    // ignore "foobar" folder
    let ignore_file = input_path.join(".gitignore");
    let ingore_content = "/target\n/foobar-1-1";
    std::fs::write(&ignore_file, ingore_content.trim()).expect(failed_message::WRITE_FILE);

    // for foobar-1, local changes only contain ".gitignore"
    let local_changes1 = get_local_changes(&input_path);

    assert_eq!(1, local_changes1.len());
    assert!(local_changes1.contains(".gitignore"));

    // for foobar-1/foobar-1-1, local changes is empty
    let local_changes2 = get_local_changes(&input_path.join("foobar-1-1"));
    assert!(local_changes2.is_empty());

    // clean-up
    std::fs::remove_dir_all(&path).unwrap();
}

/// 测试内容：
///     1、运行命令:
///         - mgit sync <path>
///     2、--no-checkout == false 时,负责创建切换 branch, 不负责 track。
///         - sync commit, 创建或切换 commits/xxxx 分支
///         - sync tag, 创建或切换 tags/x.x.x 分支
///         - sync branch, 创建或切换至同名 branch
///     3、--no-check == false 时, 负责 track
///     4、根目录是仓库,且根目录为空目录
///
/// 测试目录结构:
///   test_sync_checkout_invalid_path(.git)
///     ├─foobar-1 (.git)
///     └─foobar-2 (.git)
#[test]
fn cli_sync_checkout_invalid_path() {
    let path = env::current_dir()
        .unwrap()
        .join("target/tmp/test_sync_checkout_invalid_path");
    let input_path = path.to_str().unwrap();

    let _ = std::fs::remove_dir_all(&path);
    std::fs::create_dir_all(&path).unwrap();

    let toml_string = r#"
# This file is automatically @generated by mgit.
# Editing it as you wish.
default-branch = "develop"

[[repos]]
local = "."
remote = "https://gitee.com/icze1i0n/rust-sbert.git"
branch = "master"

[[repos]]
local = "foobar-1"
remote = "https://gitee.com/icze1i0n/rust-sbert.git"
commit = "dc1d3dbb0383f72fd4b7adcd1a4d54abf557175d"

[[repos]]
local = "foobar-2"
remote = "https://gitee.com/icze1i0n/rust-sbert.git"
tag = "v0.3.0"
"#;
    let config_file = path.join(".gitrepos");
    std::fs::write(&config_file, toml_string.trim()).expect(failed_message::WRITE_FILE);

    // initialize the repositories tree
    exec_cargo_cmd("mgit", &["sync", &input_path]);

    let cur_branch_args = ["branch", "--show-current"];
    let tracking_args = ["rev-parse", "--symbolic-full-name", "--abbrev-ref", "@{u}"];
    let root_path = &path;
    let foobar_1_path = &path.join("foobar-1");
    let foobar_2_path = &path.join("foobar-2");
    let invald_name = "invalid".to_string();

    // check initial state
    // root: master untracked
    let branch = exec_cmd(root_path, "git", &cur_branch_args).unwrap_or(invald_name.clone());
    assert_eq!(branch.trim(), "master");
    let tracking_branch = exec_cmd(root_path, "git", &tracking_args).unwrap_or(invald_name.clone());
    assert_eq!(tracking_branch.trim(), "origin/master");

    // foobar-1: commits/90296ef untracked
    let branch = exec_cmd(foobar_1_path, "git", &cur_branch_args).unwrap_or(invald_name.clone());
    assert_eq!(branch.trim(), "commits/dc1d3db");
    assert!(exec_cmd(foobar_1_path, "git", &tracking_args).is_err());

    // foobar-2: tags/1.0.3 untracked
    let branch = exec_cmd(foobar_2_path, "git", &cur_branch_args).unwrap_or(invald_name.clone());
    assert_eq!(branch.trim(), "tags/v0.3.0");
    assert!(exec_cmd(foobar_2_path, "git", &tracking_args).is_err());

    // clean-up
    std::fs::remove_dir_all(&path).unwrap();
}

/// 测试内容：
///     1、运行命令:
///         - mgit sync <path> --no-checkout --no-check
///         - mgit sync <path> --no-track
///         - mgit sync <path>
///         - mgit sync <path> --hard
///     2、--no-checkout == false 时,负责创建切换 branch, 不负责 track。
///         - sync commit, 创建或切换 commits/xxxx 分支
///         - sync tag, 创建或切换 tags/x.x.x 分支
///         - sync branch, 创建或切换至同名 branch
///     3、--no-check == false 时, 负责 track
///     4、根目录是仓库
///
/// 测试目录结构:
///   test_sync_checkout_symple(.git)
///     ├─foobar-1 (.git)
///     └─foobar-2 (.git)
#[test]
fn cli_sync_checkout_symple() {
    let path = env::current_dir()
        .unwrap()
        .join("target/tmp/test_sync_checkout_symple");
    let input_path = path.to_str().unwrap();

    let _ = std::fs::remove_dir_all(&path);
    std::fs::create_dir_all(&path).unwrap();

    let toml_string = r#"
# This file is automatically @generated by mgit.
# Editing it as you wish.
default-branch = "develop"

[[repos]]
local = "."
remote = "https://gitee.com/icze1i0n/rust-sbert.git"
branch = "master"

[[repos]]
local = "foobar-1"
remote = "https://gitee.com/icze1i0n/rust-sbert.git"
branch = "master"

[[repos]]
local = "foobar-2"
remote = "https://gitee.com/icze1i0n/rust-sbert.git"
branch = "master"
"#;
    let config_file = path.join(".gitrepos");
    std::fs::write(&config_file, toml_string.trim()).expect(failed_message::WRITE_FILE);

    // initialize the repositories tree
    exec_cargo_cmd(
        "mgit",
        &["sync", &input_path, "--no-checkout", "--no-track"],
    );

    let cur_branch_args = ["branch", "--show-current"];
    let tracking_args = ["rev-parse", "--symbolic-full-name", "--abbrev-ref", "@{u}"];
    let root_path = &path;
    let foobar_1_path = &path.join("foobar-1");
    let foobar_2_path = &path.join("foobar-2");
    let invald_name = "invalid".to_string();

    // check initial state
    // root: master untracked
    let branch = exec_cmd(root_path, "git", &cur_branch_args).unwrap_or(invald_name.clone());
    assert_eq!(branch.trim(), "master");
    assert!(exec_cmd(root_path, "git", &tracking_args).is_err());

    // foobar-1: master untracked
    let branch = exec_cmd(foobar_1_path, "git", &cur_branch_args).unwrap_or(invald_name.clone());
    assert_eq!(branch.trim(), "master");
    assert!(exec_cmd(foobar_1_path, "git", &tracking_args).is_err());

    // foobar-2: master untracked
    let branch = exec_cmd(foobar_2_path, "git", &cur_branch_args).unwrap_or(invald_name.clone());
    assert_eq!(branch.trim(), "master");
    assert!(exec_cmd(foobar_2_path, "git", &tracking_args).is_err());

    let toml_string = r#"
# This file is automatically @generated by mgit.
# Editing it as you wish.
default-branch = "develop"

[[repos]]
local = "."
remote = "https://gitee.com/icze1i0n/rust-sbert.git"
branch = "master"

[[repos]]
local = "foobar-1"
remote = "https://gitee.com/icze1i0n/rust-sbert.git"
commit = "dc1d3dbb0383f72fd4b7adcd1a4d54abf557175d"

[[repos]]
local = "foobar-2"
remote = "https://gitee.com/icze1i0n/rust-sbert.git"
tag = "v0.3.0"
"#;
    let config_file = path.join(".gitrepos");
    std::fs::write(&config_file, toml_string.trim()).expect(failed_message::WRITE_FILE);

    // test checkout function
    // root path, checkout a new branch
    // root: foobar untracked
    exec_cmd(
        root_path,
        "git",
        &["checkout", "-B", "foobar", "origin/master", "--no-track"],
    )
    .expect(failed_message::GIT_CHECKOUT);

    let branch = exec_cmd(root_path, "git", &cur_branch_args).unwrap_or(invald_name.clone());
    assert_eq!(branch.trim(), "foobar");
    assert!(exec_cmd(root_path, "git", &tracking_args).is_err());

    // sync repositories, with checkout
    exec_cargo_cmd("mgit", &["sync", &input_path, "--no-track"]);

    // root: master untracked
    let branch = exec_cmd(root_path, "git", &cur_branch_args).unwrap_or(invald_name.clone());
    assert_eq!(branch.trim(), "master");
    assert!(exec_cmd(root_path, "git", &tracking_args).is_err());

    // foobar-1: commits/90296ef untracked
    let branch = exec_cmd(foobar_1_path, "git", &cur_branch_args).unwrap_or(invald_name.clone());
    assert_eq!(branch.trim(), "commits/dc1d3db");
    assert!(exec_cmd(foobar_1_path, "git", &tracking_args).is_err());

    // foobar-2: tags/1.0.3 untracked
    let branch = exec_cmd(foobar_2_path, "git", &cur_branch_args).unwrap_or(invald_name.clone());
    assert_eq!(branch.trim(), "tags/v0.3.0");
    assert!(exec_cmd(foobar_2_path, "git", &tracking_args).is_err());

    // sync repositories, with checkout and track
    exec_cargo_cmd("mgit", &["sync", &input_path]);

    // test checkout and track function
    // root: master → origin/master
    let branch = exec_cmd(root_path, "git", &cur_branch_args).unwrap_or(invald_name.clone());
    assert_eq!(branch.trim(), "master");
    let tracking_branch = exec_cmd(root_path, "git", &tracking_args).unwrap_or(invald_name.clone());
    assert_eq!(tracking_branch.trim(), "origin/master");

    // foobar-1: commits/90296ef untracked
    let branch = exec_cmd(foobar_1_path, "git", &cur_branch_args).unwrap_or(invald_name.clone());
    assert_eq!(branch.trim(), "commits/dc1d3db");
    assert!(exec_cmd(foobar_1_path, "git", &tracking_args).is_err());

    // foobar-2: tags/1.0.3 untracked
    let branch = exec_cmd(foobar_2_path, "git", &cur_branch_args).unwrap_or(invald_name.clone());
    assert_eq!(branch.trim(), "tags/v0.3.0");
    assert!(exec_cmd(foobar_2_path, "git", &tracking_args).is_err());

    // clean-up
    std::fs::remove_dir_all(&path).unwrap();
}

/// 测试内容：
///     1、运行命令:
///         - mgit sync <path> --no-checkout --no-check
///         - mgit sync <path> --no-track
///         - mgit sync <path>
///         - mgit sync <path> --hard
///     2、--no-checkout == false 时,负责创建切换 branch, 不负责 track
///         - sync commit, 创建或切换 commits/xxxx 分支
///         - sync tag, 创建或切换 tags/x.x.x 分支
///         - sync branch, 创建或切换至同名 branch
///     3、--no-check == false 时, 负责 track
///     4、--hard == false 时，有冲突会 checkout 失败
///        --hard == true 时，放弃 chenges ，强制checkout
///     5、根目录是仓库
///
/// 测试目录结构:
///   test_sync_checkout_with_conflict(.git)
///     ├─foobar-1 (.git)
///     └─foobar-2 (.git)
#[test]
fn cli_sync_checkout_with_conflict() {
    let path = env::current_dir()
        .unwrap()
        .join("target/tmp/test_sync_checkout_with_conflict");
    let input_path = path.to_str().unwrap();

    let _ = std::fs::remove_dir_all(&path);
    std::fs::create_dir_all(&path).unwrap();

    let toml_string = r#"
# This file is automatically @generated by mgit.
# Editing it as you wish.
default-branch = "develop"

[[repos]]
local = "."
remote = "https://gitee.com/icze1i0n/rust-sbert.git"
branch = "master"

[[repos]]
local = "foobar-1"
remote = "https://gitee.com/icze1i0n/rust-sbert.git"
branch = "master"

[[repos]]
local = "foobar-2"
remote = "https://gitee.com/icze1i0n/rust-sbert.git"
branch = "master"
"#;
    let config_file = path.join(".gitrepos");
    std::fs::write(&config_file, toml_string.trim()).expect(failed_message::WRITE_FILE);

    // initialize the repositories tree
    exec_cargo_cmd(
        "mgit",
        &["sync", &input_path, "--no-checkout", "--no-track"],
    );

    let cur_branch_args = ["branch", "--show-current"];
    let tracking_args = ["rev-parse", "--symbolic-full-name", "--abbrev-ref", "@{u}"];
    let root_path = &path;
    let foobar_1_path = &path.join("foobar-1");
    let foobar_2_path = &path.join("foobar-2");
    let invald_name = "invalid".to_string();

    // check initial state
    // root: master untracked
    let branch = exec_cmd(root_path, "git", &cur_branch_args).unwrap_or(invald_name.clone());
    assert_eq!(branch.trim(), "master");
    assert!(exec_cmd(root_path, "git", &tracking_args).is_err());

    // foobar-1: master untracked
    let branch = exec_cmd(foobar_1_path, "git", &cur_branch_args).unwrap_or(invald_name.clone());
    assert_eq!(branch.trim(), "master");
    assert!(exec_cmd(foobar_1_path, "git", &tracking_args).is_err());

    // foobar-2: master untracked
    let branch = exec_cmd(foobar_2_path, "git", &cur_branch_args).unwrap_or(invald_name.clone());
    assert_eq!(branch.trim(), "master");
    assert!(exec_cmd(foobar_2_path, "git", &tracking_args).is_err());

    // ignore and .gitrepos, for confliction test
    let ignore_file = path.join(".gitignore");
    let ingore_content = format!("{}\n{}\n{}", "/target", "/foobar-1", "/foobar-2");
    std::fs::write(&ignore_file, ingore_content.trim()).expect(failed_message::WRITE_FILE);
    std::fs::write(&config_file, toml_string.trim()).expect(failed_message::WRITE_FILE);

    // create local commit
    let _ = exec_cmd(&path, "git", &["add", ".", "-f"]);
    check_git_author_identity(&path);
    let _ = exec_cmd(&path, "git", &["commit", "-am", "foobar"]);

    if let Ok(output) = exec_cmd(&path, "git", &["status"]) {
        assert_eq!(false, output.contains(".gitignore"));
        assert_eq!(false, output.contains(".gitrepos"));
    } else {
        panic!("{}", failed_message::GIT_STATUS);
    }

    // root path, set checkout a new branch
    // root: foobar untracked
    exec_cmd(
        root_path,
        "git",
        &["checkout", "-B", "foobar", "origin/master", "--no-track"],
    )
    .expect(failed_message::GIT_CHECKOUT);

    let branch = exec_cmd(root_path, "git", &cur_branch_args).unwrap_or(invald_name.clone());
    assert_eq!(branch.trim(), "foobar");
    assert!(exec_cmd(root_path, "git", &tracking_args).is_err());

    // for confliction test
    let toml_string = r#"
# This file is automatically @generated by mgit.
# Editing it as you wish.
default-branch = "develop"

[[repos]]
local = "."
remote = "https://gitee.com/icze1i0n/rust-sbert.git"
branch = "master"

[[repos]]
local = "foobar-1"
remote = "https://gitee.com/icze1i0n/rust-sbert.git"
commit = "dc1d3dbb0383f72fd4b7adcd1a4d54abf557175d"

[[repos]]
local = "foobar-2"
remote = "https://gitee.com/icze1i0n/rust-sbert.git"
tag = "v0.3.0"
"#;
    let config_file = path.join(".gitrepos");
    std::fs::write(&config_file, toml_string.trim()).expect(failed_message::WRITE_FILE);
    std::fs::write(&ignore_file, ingore_content.trim()).expect(failed_message::WRITE_FILE);

    // sync repositories, with checkout
    exec_cargo_cmd("mgit", &["sync", &input_path, "--no-track"]);

    // root: foobar untracked,  checkout failed
    let branch = exec_cmd(root_path, "git", &cur_branch_args).unwrap_or(invald_name.clone());
    assert_eq!(branch.trim(), "master");
    assert!(exec_cmd(root_path, "git", &tracking_args).is_err());

    // foobar-1: commits/90296ef untracked
    let branch = exec_cmd(foobar_1_path, "git", &cur_branch_args).unwrap_or(invald_name.clone());
    assert_eq!(branch.trim(), "commits/dc1d3db");
    assert!(exec_cmd(foobar_1_path, "git", &tracking_args).is_err());

    // foobar-2: tags/1.0.3 untracked
    let branch = exec_cmd(foobar_2_path, "git", &cur_branch_args).unwrap_or(invald_name.clone());
    assert_eq!(branch.trim(), "tags/v0.3.0");
    assert!(exec_cmd(foobar_2_path, "git", &tracking_args).is_err());

    // sync repositories, with checkout, track and hard
    exec_cargo_cmd("mgit", &["sync", &input_path, "--hard"]);

    // root: master → origin/master
    let branch = exec_cmd(root_path, "git", &cur_branch_args).unwrap_or(invald_name.clone());
    assert_eq!(branch.trim(), "master");
    let tracking_branch = exec_cmd(root_path, "git", &tracking_args).unwrap_or(invald_name.clone());
    assert_eq!(tracking_branch.trim(), "origin/master");

    // foobar-1: commits/90296ef untracked
    let branch = exec_cmd(foobar_1_path, "git", &cur_branch_args).unwrap_or(invald_name.clone());
    assert_eq!(branch.trim(), "commits/dc1d3db");
    assert!(exec_cmd(foobar_1_path, "git", &tracking_args).is_err());

    // foobar-2: tags/1.0.3 untracked
    let branch = exec_cmd(foobar_2_path, "git", &cur_branch_args).unwrap_or(invald_name.clone());
    assert_eq!(branch.trim(), "tags/v0.3.0");
    assert!(exec_cmd(foobar_2_path, "git", &tracking_args).is_err());

    // clean-up
    std::fs::remove_dir_all(&path).unwrap();
}

/// 测试内容：
///     1、运行命令:
///         - mgit sync <path> --stash
///     2、默认使用 checkout 时，不应存在 local changes
///
/// 测试目录结构:
///   test_sync_checkout_symple2(.git)
#[test]
fn cli_sync_checkout_symple2() {
    let path = env::current_dir()
        .unwrap()
        .join("target/tmp/test_sync_checkout_symple2");
    let input_path = path.to_str().unwrap();

    let _ = std::fs::remove_dir_all(&path);
    std::fs::create_dir_all(&path).unwrap();

    let toml_string = r#"
# This file is automatically @generated by mgit.
# Editing it as you wish.
default-branch = "develop"

[[repos]]
local = "."
remote = "https://gitee.com/icze1i0n/rust-sbert.git"
branch = "master"
"#;
    let config_file = path.join(".gitrepos");
    std::fs::write(&config_file, toml_string.trim()).expect(failed_message::WRITE_FILE);

    // initialize the repositories tree
    exec_cargo_cmd(
        "mgit",
        &["sync", &input_path, "--no-checkout", "--no-track"],
    );

    exec_cmd(&path, "git", &["reset", "--hard", "v0.3.0"]).expect(failed_message::GIT_RESET);

    let config_file = path.join(".gitrepos");
    std::fs::write(&config_file, toml_string.trim()).expect(failed_message::WRITE_FILE);

    // test checkout function
    // sync repositories, with checkout
    exec_cargo_cmd("mgit", &["sync", &input_path, "--stash"]);

    // for foobar-1, local changes only contain ".gitignore"
    let local_changes1 = get_local_changes(&path);
    assert_eq!(0, local_changes1.len());

    let output = exec_cmd(&path, "git", &["stash", "list"]).expect(failed_message::GIT_STASH_LIST);
    assert!(output.contains("stash@{0}"));
    assert!(!output.contains("stash@{1}"));

    // clean-up
    std::fs::remove_dir_all(&path).unwrap();
}

/// 测试内容：
///     1、运行命令:
///         - mgit sync <path> --igonre <path> --igonre <path>
///     2、--ignore 忽略对应的仓库
///     3、根目录是仓库
///
/// 测试目录结构:
///   test_sync_ignore_symple(.git)
///     ├─foobar-1 (.git)
///     └─foobar-2 (.git)
#[test]
fn cli_sync_ignore_symple() {
    let path = env::current_dir()
        .unwrap()
        .join("target/tmp/test_sync_ignore_symple");
    let input_path = path.to_str().unwrap();

    let _ = std::fs::remove_dir_all(&path);
    std::fs::create_dir_all(&path).unwrap();

    let toml_string = r#"
# This file is automatically @generated by mgit.
# Editing it as you wish.
default-branch = "develop"

[[repos]]
local = "."
remote = "https://gitee.com/icze1i0n/rust-sbert.git"
branch = "master"

[[repos]]
local = "foobar-1"
remote = "https://gitee.com/icze1i0n/rust-sbert.git"
branch = "master"

[[repos]]
local = "foobar-1/foobar-1-1"
remote = "https://gitee.com/icze1i0n/rust-sbert.git"
branch = "master"

[[repos]]
local = "foobar-2"
remote = "https://gitee.com/icze1i0n/rust-sbert.git"
branch = "master"

[[repos]]
local = "foobar-2/foobar-2-1"
remote = "https://gitee.com/icze1i0n/rust-sbert.git"
branch = "master"

[[repos]]
local = "foobar-2/foobar-2-2"
remote = "https://gitee.com/icze1i0n/rust-sbert.git"
branch = "master"
"#;
    let config_file = path.join(".gitrepos");
    std::fs::write(&config_file, toml_string.trim()).expect(failed_message::WRITE_FILE);

    // initialize the repositories tree
    exec_cargo_cmd(
        "mgit",
        &[
            "sync",
            &input_path,
            "--ignore",
            ".",
            "--ignore",
            "foobar-1",
            "--ignore",
            "foobar-2/foobar-2-1",
        ],
    );

    let root_path = path.join(".git");
    let foobar_1_path = path.join("foobar-1/.git");
    let foobar_1_1_path = path.join("foobar-1/foobar-1-1/.git");
    let foobar_2_path = path.join("foobar-2/.git");
    let foobar_2_1_path = path.join("foobar-2/foobar-2-1/.git");
    let foobar_2_2_path = path.join("foobar-2/foobar-2-2/.git");

    assert_eq!(false, root_path.is_dir());
    assert_eq!(false, foobar_1_path.is_dir());
    assert_eq!(true, foobar_1_1_path.is_dir());
    assert_eq!(true, foobar_2_path.is_dir());
    assert_eq!(false, foobar_2_1_path.is_dir());
    assert_eq!(true, foobar_2_2_path.is_dir());

    // clean-up
    std::fs::remove_dir_all(&path).unwrap();
}

pub fn check_git_author_identity(path: &PathBuf) {
    if let Err(_) = exec_cmd(path, "git", &["config", "--global", "user.email"]) {
        exec_cmd(
            path,
            "git",
            &["config", "--global", "user.email", "foobar@xmfunny.com"],
        )
        .expect(failed_message::GIT_CONFIG);
        exec_cmd(path, "git", &["config", "--global", "user.name", "foobar"])
            .expect(failed_message::GIT_CONFIG);
    }
}

/// 测试内容：
///     1、运行命令 mgit sync <path> --depth 1
///     2、得到深度为 1 的 commit
///
/// 测试目录结构:
///   test_sync_with_depth(.git)
///     ├─foobar (.git)
///     └─1.txt
#[test]
fn cli_sync_with_depth() {
    let path = env::current_dir()
        .unwrap()
        .join("target/tmp/test_sync_with_depth");
    let input_path = path.to_str().unwrap();

    let _ = std::fs::remove_dir_all(&path);
    std::fs::create_dir_all(&path).unwrap();

    let toml_string = r#"
# This file is automatically @generated by mgit.
# Editing it as you wish.
default-branch = "develop"

[[repos]]
local = "."
remote = "https://gitee.com/icze1i0n/rust-sbert.git"
commit = "dc1d3dbb0383f72fd4b7adcd1a4d54abf557175d"

[[repos]]
local = "foobar-1"
remote = "https://gitee.com/icze1i0n/rust-sbert.git"
branch = "master"

[[repos]]
local = "foobar-2"
remote = "https://gitee.com/icze1i0n/rust-sbert.git"
tag = "v0.3.0"
"#;
    let config_file = path.join(".gitrepos");
    std::fs::write(&config_file, toml_string.trim()).expect(failed_message::WRITE_FILE);

    // initialize the repositories tree
    exec_cargo_cmd("mgit", &["sync", &input_path, "--hard", "--depth", "1"]);

    let config_file = path.join(".gitrepos");
    std::fs::write(&config_file, toml_string.trim()).expect(failed_message::WRITE_FILE);

    // initialize the repositories tree
    exec_cargo_cmd("mgit", &["sync", &input_path, "--hard", "--depth", "1"]);

    // get root repo commit count
    if let Ok(output) = exec_cmd(&path, "git", &["rev-list", "--all", "--count"]) {
        assert_eq!(output.trim(), 1.to_string());
    } else {
        panic!("{}", failed_message::GIT_REV_LIST);
    }

    // get foobar-1 repo commit count
    let foobar_path = path.join("foobar-1");
    if let Ok(output) = exec_cmd(&foobar_path, "git", &["rev-list", "--all", "--count"]) {
        assert_eq!(output.trim(), 1.to_string());
    } else {
        panic!("{}", failed_message::GIT_REV_LIST);
    }

    // get foobar-2 repo commit count
    let foobar_path = path.join("foobar-2");
    if let Ok(output) = exec_cmd(&foobar_path, "git", &["rev-list", "--all", "--count"]) {
        assert_eq!(output.trim(), 1.to_string());
    } else {
        panic!("{}", failed_message::GIT_REV_LIST);
    }

    // clean-up
    std::fs::remove_dir_all(&path).unwrap();
}

/// 测试内容：
///     1、运行命令 mgit sync <path>
///     2、更新配置文件中新的 url
#[test]
fn cli_sync_new_remote_url() {
    let path = env::current_dir()
        .unwrap()
        .join("target/tmp/cli_sync_new_remote_url");
    let input_path = path.to_str().unwrap();

    let _ = std::fs::remove_dir_all(&path);
    std::fs::create_dir_all(&path).unwrap();

    let toml_string = r#"
default-branch = "develop"

[[repos]]
local = "."
remote = "https://gitee.com/ForthEspada/CS-Books.git"
commit = "fc8ba56c64b7b7e4dd2d171fd95ca620aa36d695"

[[repos]]
local = "foobar"
remote = "https://gitee.com/ForthEspada/CS-Books.git"
branch = "master"
"#;
    let config_file = path.join(".gitrepos");
    std::fs::write(&config_file, toml_string.trim()).expect(failed_message::WRITE_FILE);

    // initialize the repositories tree
    exec_cargo_cmd("mgit", &["sync", &input_path, "--hard"]);

    let repo_paths = ["", "foobar"];
    for repo_path in repo_paths {
        let dir = path.join(repo_path);
        let args = ["config", "--get", "remote.origin.url"];
        let output = exec_cmd(&dir, "git", &args).unwrap_or(String::from("invalid url"));
        assert_eq!(output.trim(), "https://gitee.com/ForthEspada/CS-Books.git");
    }

    let toml_string = r#"
default-branch = "develop"

[[repos]]
local = "."
remote = "https://gitee.com/icze1i0n/rust-sbert.git"
branch = "master"

[[repos]]
local = "foobar"
remote = "https://gitee.com/icze1i0n/rust-sbert.git"
branch = "master"
"#;
    std::fs::write(&config_file, toml_string.trim()).expect(failed_message::WRITE_FILE);

    exec_cargo_cmd("mgit", &["sync", &input_path, "--hard"]);
    for repo_path in repo_paths {
        let dir = path.join(repo_path);
        let args = ["config", "--get", "remote.origin.url"];
        let output = exec_cmd(&dir, "git", &args).unwrap_or(String::from("invalid url"));
        assert_eq!(output.trim(), "https://gitee.com/icze1i0n/rust-sbert.git");
    }

    // clean-up
    std::fs::remove_dir_all(&path).unwrap();
}
